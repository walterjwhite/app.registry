#!/bin/sh
set -a
_APPLICATION_NAME=install
_context_id_is_valid() {
	printf '%s' "$1" | $_CONF_INSTALL_GNU_GREP -Pq '^[a-zA-Z0-9_+-]+$' || _error "Context ID *MUST* only contain alphanumeric characters and +-: '^[a-zA-Z0-9_+-]+$' | ($1)"
}
_variable_is_set() {
	env | grep -cq "^$1=.*$"
}
_environment_filter() {
	$_CONF_INSTALL_GNU_GREP -P '(^_CONF_|^_OPTN_)'
}
_environment_dump() {
	[ -z "$_APPLICATION_PIPE_DIR" ] && return
	[ -z "$_ENVIRONMENT_FILE" ] && _ENVIRONMENT_FILE=$_APPLICATION_PIPE_DIR/environment
	mkdir -p $(dirname $_ENVIRONMENT_FILE)
	env | _environment_filter | sort -u | grep -v '^$' | sed -e 's/=/="/' -e 's/$/"/' >>$_ENVIRONMENT_FILE
}
_environment_load() {
	[ -z "$_ENVIRONMENT_FILE" ] && return 1
	[ ! -e "$_ENVIRONMENT_FILE" ] && {
		_warn "$_ENVIRONMENT_FILE does not exist!"
		return 2
	}
	. $_ENVIRONMENT_FILE 2>/dev/null
}
_call() {
	local _function_name=$1
	shift
	type $_function_name >/dev/null 2>&1
	local _return=$?
	if [ $_return -gt 0 ]; then
		_debug "${_function_name} does not exist"
		return $_return
	fi
	$_function_name "$@"
}
_() {
	local _successfulExitStatus=0
	if [ -n "$_SUCCESSFUL_EXIT_STATUS" ]; then
		_successfulExitStatus=$_SUCCESSFUL_EXIT_STATUS
		unset _SUCCESSFUL_EXIT_STATUS
	fi
	_info "## $*"
	if [ -z "$_DRY_RUN" ]; then
		"$@"
		local _exit_status=$?
		if [ $_exit_status -ne $_successfulExitStatus ]; then
			if [ -n "$_ON_FAILURE" ]; then
				$_ON_FAILURE
				return
			fi
			if [ -z "$_WARN_ON_ERROR" ]; then
				_error "Previous cmd failed" $_exit_status
			else
				unset _WARN_ON_ERROR
				_warn "Previous cmd failed - $* - $_exit_status"
				_ENVIRONMENT_FILE=$(mktemp -t error) _environment_dump
				return $_exit_status
			fi
		fi
	fi
}
_error() {
	if [ $# -ge 2 ]; then
		_EXIT_STATUS=$2
	else
		_EXIT_STATUS=1
	fi
	_EXIT_LOG_LEVEL=4
	_EXIT_STATUS_CODE="ERR"
	_EXIT_COLOR_CODE="$_CONF_INSTALL_C_ERR"
	_EXIT_MESSAGE="$1 ($_EXIT_STATUS)"
	_defer _environment_dump
	_defer _log_app_exit
	exit $_EXIT_STATUS
}
_success() {
	_EXIT_STATUS=0
	_EXIT_LOG_LEVEL=3
	_EXIT_STATUS_CODE="SCS"
	_EXIT_COLOR_CODE="$_CONF_INSTALL_C_SCS"
	_EXIT_MESSAGE="$1"
	_defer _log_app_exit
	exit 0
}
_on_exit() {
	[ $_EXIT ] && return 1
	_EXIT=0
	if [ -n "$_DEFERS" ]; then
		for _DEFER in $_DEFERS; do
			_call $_DEFER
		done
		unset _DEFERS
	fi
}
_defer() {
	_debug "deferring: $1"
	_DEFERS="$1 $_DEFERS"
}
_log_app_exit() {
	[ "$_EXIT_MESSAGE" ] && _print_log $_EXIT_LOG_LEVEL "$_EXIT_STATUS_CODE" "$_EXIT_COLOR_CODE" "$_EXIT_BEEP" "$_EXIT_MESSAGE"
	_log_app exit
}
_include() {
	[ ! -e $1 ] && {
		_debug "_include: $1 does NOT exist"
		return 1
	}
	. $1
}
_is_backgrounded() {
	case $(ps -o stat= -p $$) in
	*+*)
		return 1
		;;
	esac
	return 0
}
_list_pid_info() {
	_TARGET_PID=$(basename $_EXISTING_APPLICATION_PIPE)
	_TARGET_PS_DTL=$(ps -o command -p $_TARGET_PID | sed 1d | sed -e "s/^.*$_EXECUTABLE_NAME_SED_SAFE/$_EXECUTABLE_NAME_SED_SAFE/")
	_info " $_TARGET_PID - $_TARGET_PS_DTL"
}
_has_other_instances() {
	if [ $(find $_APPLICATION_CMD_DIR -maxdepth 1 -type p ! -name $$ | wc -l) -gt 0 ]; then
		return 0
	fi
	return 1
}
_kill_all() {
	_do_kill_all $_APPLICATION_PIPE_DIR
}
_kill_all_group() {
	_do_kill_all $_APPLICATION_CONTEXT_GROUP
}
_do_kill_all() {
	for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
		_kill $(basename $_EXISTING_APPLICATION_PIPE)
	done
}
_kill() {
	_warn "Killing $1"
	kill -TERM $1
}
_list() {
	_list_pid_infos $_APPLICATION_PIPE_DIR
}
_list_group() {
	_list_pid_infos $_APPLICATION_CONTEXT_GROUP
}
_list_pid_infos() {
	_info "Running processes:"
	_EXECUTABLE_NAME_SED_SAFE=$(_sed_safe $0)
	for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
		_list_pid_info
	done
}
_parent_processes() {
	[ -n "$_PARENT_PROCESSES_FUNCTION" ] && $_PARENT_PROCESSES_FUNCTION
}
_parent_processes_pgrep() {
	pgrep -P $1
}
_mktemp() {
	mktemp -t ${_APPLICATION_NAME}.${_APPLICATION_CMD}.$1
}
_init_logging() {
	unset _LOGFILE
	case $_CONF_INSTALL_LOG_LEVEL in
	0)
		local logfile=$(_mktemp debug)
		_warn "Writing debug contents to: $logfile"
		_set_logfile "$logfile"
		set -x
		;;
	esac
}
_set_logfile() {
	if [ -n "$1" ]; then
		_LOGFILE=$1
		mkdir -p $(dirname $1)
		exec >>$1
		exec 2>>$1
	fi
}
_reset_logging() {
	exec >&7
	exec 2>&8
}
_warn() {
	_print_log 3 WRN "$_CONF_INSTALL_C_WRN" "$_CONF_INSTALL_BEEP_WRN" "$1"
}
_info() {
	_print_log 2 INF "$_CONF_INSTALL_C_INFO" "$_CONF_INSTALL_BEEP_INFO" "$1"
}
_detail() {
	_print_log 2 DTL "$_CONF_INSTALL_C_DETAIL" "$_CONF_INSTALL_BEEP_DETAIL" "$1"
}
_debug() {
	_print_log 1 DBG "$_CONF_INSTALL_C_DEBUG" "$_CONF_INSTALL_BEEP_DEBUG" "($$) $1"
}
_log() {
	:
}
_colorize_text() {
	printf '\033[%s%s\033[0m' "$1" "$2"
}
_sed_remove_nonprintable_characters() {
	sed -e 's/[^[:print:]]//g'
}
_print_log() {
	if [ -z "$5" ]; then
		if test ! -t 0; then
			cat - | _sed_remove_nonprintable_characters |
				while read _line; do
					_print_log $1 $2 $3 $4 "$_line"
				done
			return
		fi
		return
	fi
	local message="$5"
	if [ $1 -lt $_CONF_INSTALL_LOG_LEVEL ]; then
		return
	fi
	[ -n "$_LOGGING_CONTEXT" ] && message="$_LOGGING_CONTEXT - $message"
	local _message_date_time=$(date +"$_CONF_INSTALL_DATE_FORMAT")
	if [ $_BACKGROUNDED ] && [ $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD ]; then
		$_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD "$2" "$_message" &
	fi
	_log "$1" "$2" "$message"
	[ -n "$4" ] && _beep "$4"
	_log_to_file "$2" "$_message_date_time" "${_LOG_INDENT}$message"
	_log_to_console "$3" "$2" "$_message_date_time" "${_LOG_INDENT}$message"
}
_add_logging_context() {
	[ -z "$1" ] && return 1
	if [ -z "$_LOGGING_CONTEXT" ]; then
		_LOGGING_CONTEXT="$1"
		return
	fi
	_LOGGING_CONTEXT="$_LOGGING_CONTEXT.$1"
}
_remove_logging_context() {
	[ -z "$_LOGGING_CONTEXT" ] && return 1
	case $_LOGGING_CONTEXT in
	*.*)
		_LOGGING_CONTEXT=$(printf '%s' "$_LOGGING_CONTEXT" | sed 's/\.[a-z0-9 _-]*$//')
		;;
	*)
		unset _LOGGING_CONTEXT
		;;
	esac
}
_increase_indent() {
	_LOG_INDENT="$_LOG_INDENT${_CONF_INSTALL_INDENT}"
}
_decrease_indent() {
	_LOG_INDENT=$(printf '%s' "$_LOG_INDENT" | sed -e "s/${_CONF_INSTALL_INDENT}$//")
	[ ${#_LOG_INDENT} -eq 0 ] && _reset_indent
}
_reset_indent() {
	unset _LOG_INDENT
}
_log_to_file() {
	if [ $_NON_INTERACTIVE ] || [ $_LOGFILE ]; then
		if [ $_CONF_INSTALL_AUDIT -gt 0 ]; then
			printf >&$_NLOG_TARGET '%s %s %s\n' "$1" "$2" "$3"
		else
			printf >&$_NLOG_TARGET '%s\n' "$3"
		fi
		_syslog "$3"
	fi
}
_log_to_console() {
	[ $_NO_WRITE_STDERR ] && return
	_is_open $_LOG_TARGET || return
	[ $_NON_INTERACTIVE ] && [ -z $_LOGFILE ] && return
	if [ $_CONF_INSTALL_AUDIT -gt 0 ]; then
		printf >&$_LOG_TARGET '\033[%s%s \033[0m%s %s\n' "$1" "$2" "$3" "$4"
	else
		printf >&$_LOG_TARGET '\033[%s%s \033[0m\n' "$1" "$4"
	fi
}
_is_open() {
	(: >&"$1") 2>/dev/null
}
_log_app() {
	_debug "$_APPLICATION_NAME:$_APPLICATION_CMD - $1 ($$)"
}
_syslog() {
	logger -i -t "$_APPLICATION_NAME.$_APPLICATION_CMD" "$1"
}
_beep() {
	if [ -n "$_BEEPING" ]; then
		_debug "Another 'beep' is in progress"
		return 1
	fi
	_BEEPING=1
	_do_beep "$@" &
}
_do_beep() {
	if [ -e /dev/speaker ]; then
		printf '%s' "$1" >/dev/speaker
	fi
	unset _BEEPING
}
_sudo_precmd() {
	_beep $_CONF_INSTALL_SUDO_BEEP_TONE
}
_on_exit_beep() {
	local current_time=$(date +%s)
	local timeout=$(($current_time + $_CONF_INSTALL_BEEP_TIMEOUT))
	[ $current_time -le $timeout ] && return 1
	local beep_code
	if [ $_EXIT_STATUS -gt 0 ]; then
		beep_code="$_CONF_INSTALL_BEEP_ERR"
	else
		beep_code="$_CONF_INSTALL_BEEP_SCS"
	fi
	_beep "$beep_code" &
}
_interactive_alert_if() {
	_is_interactive_alert_enabled && _interactive_alert "$@"
}
_is_interactive_alert_enabled() {
	grep -cq '^_OPTN_INSTALL_INTERACTIVE_ALERT=1$' $_CONF_INSTALL_APPLICATION_CONFIG_PATH 2>/dev/null
}
_read_ifs() {
	stty -echo
	_read_if "$@"
	stty echo
}
_continue_if() {
	_read_if "$1" _PROCEED "$2"
	local proceed="$_PROCEED"
	unset _PROCEED
	if [ -z "$proceed" ]; then
		_DEFAULT=$(printf '%s' $2 | awk -F'/' {'print$1'})
		proceed=$_DEFAULT
	fi
	local proceed=$(printf '%s' "$proceed" | tr '[:lower:]' '[:upper:]')
	if [ $proceed = "N" ]; then
		return 1
	fi
	return 0
}
_read_if() {
	if [ $(env | grep -c "^$2=.*") -eq 1 ]; then
		_debug "$2 is already set"
		return 1
	fi
	[ $_NON_INTERACTIVE ] && _error "Running in non-interactive mode and user input was requested: $@" 10
	_print_log 9 STDI "$_CONF_INSTALL_C_STDIN" "$_CONF_INSTALL_BEEP_STDIN" "$1 $3"
	_interactive_alert_if $1 $3
	read -r $2
}
_sudo() {
	[ $# -eq 0 ] && _error 'No arguments were provided to _sudo'
	[ $(whoami) == 'root' ] && [ -z $_SUDO_REQUIRED ] && {
		$@
		return
	}
	_require "$_SUDO_CMD" _SUDO_CMD
	if [ -z "$_NON_INTERACTIVE" ]; then
		$_SUDO_CMD -n ls >/dev/null 2>&1 || _sudo_precmd "$@"
	fi
	$_SUDO_CMD $_SUDO_OPTIONS "$@"
}
_waitee_init() {
	_APPLICATION_PIPE=$_APPLICATION_CMD_DIR/$$
	_APPLICATION_PIPE_DIR=$(dirname $_APPLICATION_PIPE)
	mkdir -p $_APPLICATION_PIPE_DIR
	mkfifo $_APPLICATION_PIPE
	$_CONF_INSTALL_WAITER_LEVEL "($_APPLICATION_CMD) Please use -w=$$"
	_defer _waitee_done
}
_waitee_done() {
	[ -z "$_EXIT_STATUS" ] && _EXIT_STATUS=0
	if [ -n "$_WAITEE" ] && [ -e $_APPLICATION_PIPE ]; then
		_info "$0 process completed, notifying ($_EXIT_STATUS)"
		printf '%s\n' "$_EXIT_STATUS" >$_APPLICATION_PIPE
		_info "$0 downstream process picked up"
	fi
	rm -f $_APPLICATION_PIPE
}
_waiter() {
	if [ -n "$_WAITER_PID" ]; then
		_UPSTREAM_APPLICATION_PIPE=$(find $_APPLICATION_CONTEXT_GROUP -type p -name $_WAITER_PID 2>/dev/null | head -1)
		if [ -z "$_UPSTREAM_APPLICATION_PIPE" ]; then
			_error "$_WAITER_PID not found"
		fi
		if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
			_warn "$_UPSTREAM_APPLICATION_PIPE does not exist, did upstream start?"
			return
		fi
		_info "Waiting for upstream to complete: $_WAITER_PID"
		while [ 1 ]; do
			if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
				_error "Upstream pipe no longer exists"
			fi
			_UPSTREAM_APPLICATION_STATUS=$(_timeout $_CONF_INSTALL_WAIT_INTERVAL "_waiter:upstream" cat $_UPSTREAM_APPLICATION_PIPE 2>/dev/null)
			local _UPSTREAM_STATUS=$?
			if [ $_UPSTREAM_STATUS -eq 0 ]; then
				if [ -z "$_UPSTREAM_APPLICATION_STATUS" ] || [ $_UPSTREAM_APPLICATION_STATUS -gt 0 ]; then
					_error "Upstream exited with error ($_UPSTREAM_APPLICATION_STATUS)"
				fi
				_warn "Upstream finished: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
				break
			fi
			_detail " Upstream is still running: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
		done
	fi
}
_contains_argument() {
	local _key=$1
	shift
	for _ARG in "$@"; do
		case $_ARG in
		$_key)
			return 0
			;;
		esac
	done
	return 1
}
_require() {
	local level=error
	if [ -z "$1" ]; then
		[ -n "$_WARN" ] && level=warn
		_$level "$2 required $_REQUIRE_DETAILED_MESSAGE" $3
		return 1
	fi
	unset _REQUIRE_DETAILED_MESSAGE
}
_value_in() {
	local level=error
	[ -n "$_WARN" ] && level=warn
	printf '%s\n' "$1" | $_CONF_INSTALL_GNU_GREP -Pcq "^($2)$" || _$level "$1 is not in ^($2)$"
}
_beep() {
	if [ -n "$_BEEPING" ]; then
		_debug "Another 'beep' is in progress"
		return 1
	fi
	_BEEPING=1
	_do_beep "$@" &
}
_do_beep() {
	if [ -e /dev/speaker ]; then
		printf '%s' "$1" >/dev/speaker
	fi
	unset _BEEPING
}
_sudo_precmd() {
	_beep $_CONF_INSTALL_SUDO_BEEP_TONE
}
_on_exit_beep() {
	local current_time=$(date +%s)
	local timeout=$(($current_time + $_CONF_INSTALL_BEEP_TIMEOUT))
	[ $current_time -le $timeout ] && return 1
	local beep_code
	if [ $_EXIT_STATUS -gt 0 ]; then
		beep_code="$_CONF_INSTALL_BEEP_ERR"
	else
		beep_code="$_CONF_INSTALL_BEEP_SCS"
	fi
	_beep "$beep_code" &
}
_is_feature() {
	printf '%s' $_SETUP | grep -c /feature/
}
_disable_feature() {
	if [ -z "$_FEATURE_DISABLED" ]; then
		_warn "Error installing feature: $_FEATURE ($1)"
	fi
	printf '%s\n' $(_feature_key $1)_DISABLED=1 | _metadata_write
}
_is_feature_enabled() {
	local _feature_key=$(_feature_key $1)
	if [ $(env | grep -c "^${_feature_key}_DISABLED=1$") -gt 0 ]; then
		_warn "$1 is disabled"
		return 1
	fi
	return 0
}
_feature_key() {
	printf '%s\n' "_FEATURE_${1}" | tr '[:lower:]' '[:upper:]' | tr '-' '_'
}
_freebsd_update() {
	local freebsd_update_configuration_file=$freebsd_root/etc/freebsd-update.conf
	local freebsd_update_options
	[ -n "$$freebsd_root" ] && freebsd_update_options="-b $_JAIL_ZFS_MOUNTPOINT/$_JAIL_NAME"
	grep -qs '^CreateBootEnv yes' $freebsd_update_configuration_file || {
		printf '# disable creation of boot environments, will be handled automatically via system-maintenance app\n' >>$freebsd_update_configuration_file
		printf 'CreateBootEnv no\n' >>$freebsd_update_configuration_file
	}
	env PAGER=cat freebsd-update $freebsd_update_options "$@" --not-running-from-cron fetch install
}
_app_default_bootstrap() {
	:
}
_app_default_install() {
	if [ -n $_USER ]; then
		_SUDO_OPTIONS="-u $USER" _sudo xdg-mime default $1.desktop $2
		return $?
	fi
	xdg-mime default $1.desktop $2
}
_app_default_uninstall() {
	:
}
_app_default_is_installed() {
	:
}
_app_default_enabled() {
	return 0
}
_go_bootstrap_platform_post() {
	[ -e /usr/local/bin/go123 ] && [ ! -e /usr/local/bin/go ] && {
		ln -s /usr/local/bin/go123 /usr/local/bin/go
		ln -s /usr/local/bin/gofmt123 /usr/local/bin/gofmt
	}
}
_user_bootstrap() {
	_sudo mkdir -p /root/.ssh/socket
	_sudo chmod -R 700 /root/.ssh/socket
	app-install configuration
}
_user_install() {
	_users_add "$1"
}
_user_uninstall() {
	. "$1"
	_require "$username" "username"
	rmuser -y $username
}
_user_is_installed() {
	:
}
_user_enabled() {
	return 0
}
_users_add_argument() {
	if [ -n "$2" ]; then
		user_options="$user_options $1 $2"
	fi
}
_users_add() {
	. $1
	if [ "root" != "$username" ]; then
		_sudo pw user show $username >/dev/null 2>&1 || {
			_info "### Add User: $1: $username"
			user_options="-n $username -m"
			_users_add_argument "-g" "$gid"
			_users_add_argument "-G" "$grouplist"
			_users_add_argument "-s" "$shell"
			_users_add_argument "-u" "$uid"
			_sudo pw useradd $user_options
		}
	else
		_info "# Setting shell to $shell for root"
		_sudo chsh -s "$shell"
	fi
	if [ -n "$password" ]; then
		_info "# Setting password $shell for $username"
		_sudo chpass -p "$password" $username
	fi
	_users_configure
	_users_cleanup
}
_users_get_data() {
	printf '%s\n' "$username" | tr ' ' '\n'
}
_users_cleanup() {
	unset user_options username gid grouplist shell uid password system
}
_users_configure() {
	local user_home=$(grep "^$username:" /etc/passwd | cut -f6 -d':')
	sudo=$SUDO_CMD _prepare_ssh_conf $user_home $username
	local original_pwd=$PWD
	cd /tmp
	if [ -n "$system" ]; then
		_warn "$username is a system user, bypassing configuration"
	else
		_warn "_CONF_FREEBSD_INSTALLER_HOSTNAME:$_CONF_FREEBSD_INSTALLER_HOSTNAME"
		_WARN_ON_ERROR=1 _NON_INTERACTIVE=1 _FREEBSD_INSTALLER=1 _NO_WRITE_STDERR=1 _SUDO_REQUIRED=1 _ _sudo \
			--preserve-env=_CONF_GIT_MIRROR,_WARN_ON_ERROR,_LOG_TARGET,_NON_INTERACTIVE,_CONF_FREEBSD_INSTALLER_HOSTNAME,_NO_WRITE_STDERR,http_proxy,https_proxy \
			-H -u $username conf restore || _user_configure_debug
	fi
	cd $original_pwd
}
_user_configure_debug() {
	_warn "Error restoring configuration for $username"
	cat $user_home/.ssh/id_*.pub
	cat $user_home/.ssh/authorized_keys
	cat $user_home/.ssh/config
}
_pkg_update() {
	_pkg_bootstrap
	_sudo pkg $_PKG_OPTIONS upgrade $_PACKAGE_OPTIONS $@
	_sudo pkg $_PKG_OPTIONS autoremove $_PACKAGE_OPTIONS $@
}
_pkg_install() {
	_pkg_bootstrap
	_sudo pkg $_PKG_OPTIONS install $_PACKAGE_OPTIONS $@
}
_pkg_uninstall() {
	_pkg_bootstrap
	_sudo pkg $_PKG_OPTIONS delete $_PACKAGE_OPTIONS $@
}
_pkg_is_installed() {
	_pkg_bootstrap
	pkg $_PKG_OPTIONS info -e $1 2>/dev/null
}
_pkg_bootstrap() {
	[ $_PKG_BOOTSTRAPPED ] && return
	ASSUME_ALWAYS_YES=yes
	_PKG_BOOTSTRAPPED=1
	if [ -n "$_ROOT" ] && [ "$_ROOT" != "/" ]; then
		_pkg_cache_already_mounted || _pkg_cache_mount
		_PKG_OPTIONS="-r $_ROOT"
	fi
	_pkg_enable_proxy
	_sudo pkg $_PKG_OPTIONS update -q
}
_pkg_cache_already_mounted() {
	mount | awk {'print$3'} | grep -q "$_ROOT/var/cache/pkg$"
}
_pkg_cache_mount() {
	[ -e /sbin/mount_nullfs ] || return 1
	[ -e /var/cache/pkg ] || return 1
	_sudo mkdir -p $_ROOT/var/cache/pkg
	_info "Mounting host's package cache"
	_sudo mount -t nullfs /var/cache/pkg $_ROOT/var/cache/pkg || {
		_warn "Error mounting host's package cache"
		_warn "pkg cache mounts: $(mount | awk {'print$3'} | grep \"^$_ROOT/var/cache/pkg$\")"
		_warn "mounts: $(mount | awk {'print$3'})"
		_warn "/var/cache/pkg:"
		return 1
	}
	_defer _pkg_cache_umount
	_info "Mounted host's package cache"
}
_pkg_cache_umount() {
	umount $_ROOT/var/cache/pkg
}
_pkg_bootstrap_platform() {
	_pkg_bootstrap
}
_pkg_bootstrap_is_pkg_available() {
	return 0
}
_pkg_enable_proxy() {
	[ -z "$http_proxy" ] && return 1
	[ $_PKG_PROXY_ENABLED ] && return 2
	_PKG_PROXY_ENABLED=1
	_defer _pkg_disable_proxy
	_warn "[install] Configuring pkg to use an HTTP proxy: $http_proxy"
	local _updated_pkg_conf=$(mktemp)
	if [ -e $_ROOT/usr/local/etc/pkg.conf ]; then
		grep -v '^pkg_env' $_ROOT/usr/local/etc/pkg.conf >$_updated_pkg_conf
		mv $_updated_pkg_conf $_ROOT/usr/local/etc/pkg.conf
	fi
	mkdir -p $_ROOT/usr/local/etc
	printf 'pkg_env: { http_proxy: "%s"}\n' "$http_proxy" >>$_ROOT/usr/local/etc/pkg.conf
}
_pkg_disable_proxy() {
	[ -z "$http_proxy" ] && return 1
	unset _PKG_PROXY_ENABLED
	_warn "[freebsd-installer] Disabling HTTP proxy: $http_proxy"
	$_CONF_INSTALL_GNU_SED -i "s/^pkg_env/#pkg_env/" $_ROOT/usr/local/etc/pkg.conf
}
_is_latest() {
	[ ! -e $_INSTALL_LIBRARY_PATH/$1 ] && return 1
	[ ! -e $_INSTALL_LIBRARY_PATH/$1/.metadata ] && return 1
	_INSTALLED_APPLICATION_GIT_URL=$(grep _APPLICATION_GIT_URL $_INSTALL_LIBRARY_PATH/$1/.metadata | cut -f2 -d= | tr -d '"')
	_LATEST_APPLICATION_VERSION=$(git ls-remote $_CONF_INSTALL_APP_REGISTRY_GIT_URL 2>/dev/null | head -1 | cut -f1)
	_INSTALLED_APPLICATION_VERSION=$(grep _APPLICATION_VERSION $_INSTALL_LIBRARY_PATH/$1/.metadata | cut -f2 -d. | tr -d '"')
	[ "$_LATEST_APPLICATION_VERSION" != "$_INSTALLED_APPLICATION_VERSION" ] && return 1
	return 0
}
_setup_project() {
	if [ -e "$_CONF_INSTALL_APP_REGISTRY_ZIP_ARCHIVE" ]; then
		_install_app_registry_from_zip
	else
		_clone
	fi
	_is_latest $_TARGET_APPLICATION_NAME && {
		if [ -z "$_INSTALL_FORCE" ]; then
			_warn "Latest version of app is already installed: $_TARGET_APPLICATION_NAME [$_LATEST_APPLICATION_VERSION]"
			return 1
		fi
	}
	_is_app
	_TARGET_PLATFORM=$_PLATFORM
	_application_settings
	_application_defaults $_TARGET_PLATFORM
	[ $_OPTN_INSTALL_BYPASS_UNINSTALL ] || _uninstall
	_prepare_target
	_bootstrap
	_metadata_write_app
	_install $_TARGET_PLATFORM
	_setup setup
	_features $_TARGET_PLATFORM/feature
	_setup post-setup
	_info "$_TARGET_APPLICATION_NAME - Completed installation"
}
_checksum() {
	_require_file "$1" "File to checksum"
	$_CONF_INSTALL_CHECKSUM_CMD $1
}
_is_app() {
	[ ! -e .app ] && return 1
	return 0
}
_is_clean() {
	[ -n "$(git status --porcelain)" ] && _error "Working directory is dirty, please commit changes first"
}
_features() {
	if [ ! -e $1 ]; then
		if [ -z "$_WARN" ]; then
			_warn "No features to install"
		fi
		return 1
	fi
	_info "Installing ${_FEATURE_MESSAGE}features"
	local feature
	for feature in $(_features_find $1 | sort -u); do
		_FEATURE_NAME=$(printf '%s' $feature | sed -e 's/\.feature/\.feature\n/g' | $_CONF_INSTALL_GNU_GREP -Po '/[a-zA-Z0-9-_]*.feature$' | sed -e 's/^\///' -e 's/\.feature$//' | tr '\n' '_' | sed -e 's/_$//')
		_application_defaults $feature
		_is_feature_enabled $_FEATURE_NAME || {
			_FEATURE_DISABLED=1 _disable_feature $_FEATURE_NAME
			_features_unset
			continue
		}
		_feature $feature || {
			_disable_feature $_FEATURE_NAME
			_features_unset
			continue
			feature_error=1
		}
		_FEATURE_MESSAGE="children " _WARN=0 _features $feature/feature
		_features_unset
	done
}
_features_unset() {
	unset _FEATURE_NAME _FEATURE_DISABLED
}
_features_find() {
	if [ -z "$_FEATURE_MESSAGE" ]; then
		find $1 -type d \( -name '*.feature' -and ! -path '*/*.feature/*' \)
	else
		find $1 -type d -name '*.feature' -and ! -name "$1"
	fi
}
_feature() {
	_detail $_FEATURE_NAME
	_install $1 || return $?
	_feature_setup $1 || return $?
}
_feature_setup() {
	local setup_script
	for setup_script in $(find $1 -type f \( -path "$1/setup/*" \) | sort -u); do
		_setup_run_script $setup_script || return 1
	done
}
_do_clone() {
	if [ -n "$1" ] && [ -e $1 ]; then
		if [ -z "$clean_workspace" ] || [ $clean_workspace -eq 0 ]; then
			local opwd=$PWD
			cd $1
			git pull || _error "Unable to update : $1"
			cd $opwd
			return
		fi
		cd
		rm -rf $1
	fi
	if [ -n "$project_name" ]; then
		git clone $project_name $1 >/dev/null 2>&1 && return
	fi
	local repository_url
	for repository_url in $git_mirrors; do
		local project_url=$repository_url
		if [ -n "$project_name" ]; then
			project_url=$project_url/$project_name
		fi
		git clone $project_url $1 >/dev/null 2>&1 && {
			_detail "Using $project_url -> $1"
			return
		}
	done
	return 1
}
_clone() {
	_info "Git Clone: $_TARGET_APPLICATION_NAME"
	git_mirrors=$_CONF_INSTALL_APP_REGISTRY_GIT_URL clean_workspace=$_CONF_INSTALL_CLEAN_APP_REGISTRY_WORKSPACE _do_clone $_CONF_INSTALL_DATA_REGISTRY_PATH && {
		cd $_CONF_INSTALL_DATA_REGISTRY_PATH
		cd $_TARGET_APPLICATION_NAME || _error "$_TARGET_APPLICATION_NAME does not exist in the registry"
		_TARGET_APPLICATION_VERSION=$(git branch --no-color --show-current).$(git rev-parse HEAD)
		_detail "Cloned registry and $_TARGET_APPLICATION_NAME exists"
		return
	}
	_error "Unable to clone: $_TARGET_APPLICATION_GIT_URL in any of $_CONF_INSTALL_APP_REGISTRY_GIT_URL"
}
_git_does_repository_exist() {
	case $1 in
	http*)
		local http_status_code=$(curl -Is $1 2>/dev/null | head -n 1 | cut -d$' ' -f2)
		if [ $http_status_code -lt 400 ]; then
			return 0
		fi
		;;
	*:*)
		git ls-remote $1 >/dev/null 2>&1 && return 0
		;;
	*)
		if [ -e $1 ]; then
			return 0
		fi
		;;
	esac
	return 1
}
_require_ssh_keys() {
	if [ $(find ~/.ssh -maxdepth 1 -type f -name '*.pub' | wc -l) -eq 0 ]; then
		_error "SSH public key is required"
	fi
}
_install_app_registry_from_zip() {
	_detail "Installing from app.registry zip"
	local temp_dir=$(mktemp -d)
	_extract $_CONF_INSTALL_APP_REGISTRY_ZIP_ARCHIVE $temp_dir
	[ -n "$_CONF_INSTALL_CLEAN_APP_REGISTRY_WORKSPACE" ] && rm -rf $_CONF_INSTALL_DATA_REGISTRY_PATH
	mv $temp_dir/app.registry-master $_CONF_INSTALL_DATA_REGISTRY_PATH
	rm -rf $temp_dir
	cd $_CONF_INSTALL_DATA_REGISTRY_PATH
	cd $_TARGET_APPLICATION_NAME
	_TARGET_APPLICATION_VERSION=$(sha1sum --quiet $(find ~/.data/install/registry-not-git/install -type f | sort -u) | sha1sum --quiet -)
}
_prepare_target() {
	_sudo rm -rf $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME
	_sudo mkdir -p $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME
}
_install() {
	_sudo mkdir -p $_INSTALL_BIN_PATH
	_install_help $1
	local installed_files=$(mktemp)
	_install_cmds $1 $installed_files
	_install_uninstall $1
	_install_files_files $1 $installed_files
	_install_update_files $installed_files
	if [ -e $1/.metadata ]; then
		cat $1/.metadata | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.metadata"
	fi
}
_install_files() {
	if [ -e $1 ] && [ $(find $1 -type f | wc -l) -gt 0 ]; then
		if [ -n "$3" ]; then
			local files_sed_safe=$(_sed_safe $1)
			local target_sed_safe=$(_sed_safe $2)
			find $1 -type f | sed -e "s/^$files_sed_safe/$target_sed_safe/" >>$3
		fi
		_sudo mkdir -p $2
		tar -c $_TAR_ARGS -C $1 . | _sudo tar -xop $_TAR_ARGS -C $2
	fi
}
_install_help() {
	_install_files $1/help $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/help
}
_install_cmds() {
	if [ "$_TARGET_APPLICATION_NAME" = "$_APPLICATION_NAME" ]; then
		printf '%s\n' "$_INSTALL_BIN_PATH/$(basename $0)" >>$2
	fi
	_install_files $1/bin $_INSTALL_BIN_PATH $2
}
_install_uninstall() {
	_install_files $1/uninstall $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/uninstall
}
_install_files_files() {
	_install_files $1/files/_ROOT_ $_ROOT $2
	_install_files $1/files/_APPLICATION_ROOT_ "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME" $2
}
_install_update_files() {
	if [ -n "$_ROOT" ] && [ "$_ROOT" != "/" ]; then
		local root_sed_safe=$(_sed_safe $_ROOT)
		$_CONF_INSTALL_GNU_SED -i "s/^$root_sed_safe//" $1
	fi
	_INSTALLED_FILES="$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files"
	cat $1 | _write "$_INSTALLED_FILES"
	rm -f $1
	_sudo chmod 444 $_INSTALLED_FILES
}
_metadata_write_app() {
	printf '_APPLICATION_NAME="%s"\n' "$_TARGET_APPLICATION_NAME" | _metadata_write
	printf '_APPLICATION_GIT_URL="%s"\n' "$_TARGET_APPLICATION_GIT_URL" | _metadata_write
	printf '_APPLICATION_INSTALL_DATE="%s"\n' "$_TARGET_APPLICATION_INSTALL_DATE" | _metadata_write
	printf '_APPLICATION_BUILD_DATE="%s"\n' "$_TARGET_APPLICATION_BUILD_DATE" | _metadata_write
	printf '_APPLICATION_VERSION="%s"\n' "$_TARGET_APPLICATION_VERSION" | _metadata_write
}
_metadata_write() {
	_write $_TARGET_APPLICATION_METADATA_PATH
}
_install_metadata_write() {
	_write $_APPLICATION_METADATA_PATH
}
_metadata_write_platform() {
	env | grep '^_BOOTSTRAP_' | _install_metadata_write
}
_app_install() {
	_DEPENDENCY=1 app-install $1
}
_app_uninstall() {
	app-uninstall $1
}
_app_is_installed() {
	[ -e $_CONF_INSTALL_LIBRARY_PATH/.metadata ] && return 0
	return 1
}
_app_is_file() {
	return 1
}
_expect_install() {
	$1 >/dev/null 2>&1
}
_expect_uninstall() {
	_warn "expect uninstall - Not implemented"
}
_expect_is_installed() {
	return 1
}
_expect_is_file() {
	return 0
}
_go_bootstrap() {
	_go_bootstrap_is_go_available || {
		_go_bootstrap_platform
		_go_bootstrap_is_go_available || _GO_DISABLED=1
	}
}
_go_bootstrap_is_go_available() {
	which go >/dev/null 2>&1
}
_go_install() {
	GO111MODULE=on _sudo go install $_GO_OPTIONS "$@" || {
		_warn "go install failed: $_GO_OPTIONS $@"
		_warn "  http_proxy: $http_proxy"
		_warn "  git  proxy: $(git config --global http.proxy)"
	}
}
_go_update() {
	:
}
_go_uninstall() {
	_sudo go uninstall "$@"
}
_go_is_installed() {
	return 1
}
_go_is_file() {
	return 1
}
_npm_bootstrap() {
	_npm_bootstrap_is_npm_available || {
		_npm_bootstrap_platform
		_npm_bootstrap_is_npm_available || _NPM_DISABLED=1
	}
	_npm_setup_proxy
}
_npm_bootstrap_is_npm_available() {
	which npm >/dev/null 2>&1
}
_npm_install() {
	local npm_package
	for npm_package in "$@"; do
		_npm_is_installed $npm_package || _sudo npm install -s -g "$npm_package"
	done
}
_npm_uninstall() {
	_sudo npm uninstall -s -g "$@"
}
_npm_is_installed() {
	npm list -g $1 >/dev/null
}
_npm_is_file() {
	return 1
}
_npm_setup_proxy() {
	if [ -n "$http_proxy" ]; then
		_warn "Configuring NPM to use an HTTP proxy: $http_proxy"
		npm config set proxy $http_proxy
		npm config set https-proxy $https_proxy
		_defer _npm_clear_proxy
	fi
}
_npm_clear_proxy() {
	_warn "Reverting NPM HTTP proxy: $http_proxy"
	npm config rm proxy
	npm config rm https-proxy
}
_package_bootstrap() {
	[ -z "$_INSTALL_INSTALLER" ] && return 1
	_${_INSTALL_INSTALLER}_bootstrap_is_${_INSTALL_INSTALLER}_available || {
		_${_INSTALL_INSTALLER}_bootstrap_platform
		_${_INSTALL_INSTALLER}_bootstrap_is_${_INSTALL_INSTALLER}_available || _PACKAGE_DISABLED=1
	}
	_${_INSTALL_INSTALLER}_bootstrap
}
_package_bootstrap_is_package_available() {
	[ -z "$_INSTALL_INSTALLER" ] && return 1
	_${_INSTALL_INSTALLER}_bootstrap_is_package_available
}
_package_install() {
	_package_validate_conf || return $?
	local packages
	local package
	for package in "$@"; do
		_package_is_installed $package || {
			if [ -n "$packages" ]; then
				packages="$packages $package"
			else
				packages="$package"
			fi
		}
	done
	if [ -n "$packages" ]; then
		_${_INSTALL_INSTALLER}_install "$packages"
	fi
}
_package_update() {
	_package_validate_conf || return $?
	[ -n "$_PACKAGE_UPDATES_DISABLED" ] && {
		_warn "$_INSTALL_INSTALLER updates are disabled"
		return 1
	}
	_info "Updating via ${_INSTALL_INSTALLER}"
	_${_INSTALL_INSTALLER}_update
}
_package_uninstall() {
	_package_validate_conf || return $?
	_${_INSTALL_INSTALLER}_uninstall "$@"
}
_package_validate_conf() {
	_package_enabled || {
		if [ -n "$_INSTALL_INSTALLER" ]; then
			_warn "$_INSTALL_INSTALLER is disabled"
		else
			_warn "_INSTALL_INSTALLER is unset"
		fi
		return 1
	}
	_require "$_INSTALL_INSTALLER" _INSTALL_INSTALLER
}
_package_is_installed() {
	_require "$_INSTALL_INSTALLER" _INSTALL_INSTALLER
	_${_INSTALL_INSTALLER}_is_installed "$@"
}
_package_is_file() {
	return 1
}
_package_enabled() {
	if [ -z "$_PACKAGE_DISABLED" ] || [ $_PACKAGE_DISABLED -eq 0 ]; then
		return 0
	fi
	return 1
}
_pypi_bootstrap() {
	_pypi_bootstrap_is_pypi_available || {
		_pypi_bootstrap_platform
		_pypi_bootstrap_is_pypi_available || _PYPI_DISABLED=1
	}
}
_pypi_bootstrap_is_pypi_available() {
	which pip >/dev/null 2>&1
}
_pypi_install() {
	_sudo pip install -U --no-input "$@" >/dev/null
}
_pypi_uninstall() {
	_sudo pip uninstall -y "$@" >/dev/null
}
_pypi_is_installed() {
	_error "PIP - is installed - NOT IMPLEMENTED"
}
_pypi_is_file() {
	return 1
}
_run_install() {
	sh $1
}
_run_uninstall() {
	_warn "run uninstall - Not implemented"
}
_run_is_installed() {
	return 1
}
_run_is_file() {
	return 0
}
_rust_bootstrap() {
	_rust_bootstrap_is_rust_available || {
		_rust_bootstrap_platform
		_rust_bootstrap_is_rust_available || _RUST_DISABLED=1
	}
}
_rust_bootstrap_is_rust_available() {
	which cargo >/dev/null 2>&1
}
_rust_install() {
	_sudo cargo install "$@"
}
_rust_update() {
	_sudo cargo update "$@"
}
_rust_uninstall() {
	_sudo cargo uninstall "$@"
}
_rust_is_installed() {
	_error "RUST - is installed - NOT IMPLEMENTED"
}
_rust_is_file() {
	return 1
}
_user_bootstrap() {
	:
}
_user_install() {
	:
}
_user_uninstall() {
	:
}
_user_is_installed() {
	return 1
}
_user_is_file() {
	return 0
}
_user_enabled() {
	return 1
}
_bootstrap() {
	[ "$_APPLICATION_NAME" = "$_TARGET_APPLICATION_NAME" ] && _metadata_write_platform
	[ -z "$_PLATFORM_PACKAGES" ] && return 1
	[ -n "$_BOOTSTRAP_PLATFORM_PACKAGES_INSTALLED" ] && return 2
	_info "Installing pre-requisites"
	_setup_run_do_bootstrap package
	_package_install $_PLATFORM_PACKAGES
	_BOOTSTRAP_PLATFORM_PACKAGES_INSTALLED=1
	_metadata_write_platform
}
_npm_bootstrap_platform() {
	_package_install $_NPM_PACKAGE
}
_rust_bootstrap_platform() {
	_package_install $_RUST_PACKAGE
}
_pypi_bootstrap_platform() {
	_package_install $_PYPI_PACKAGE
}
_go_bootstrap_platform() {
	_package_install $_GO_PACKAGE
	_call _go_bootstrap_platform_post
}
_settings_init() {
	if [ -z "$_ROOT" ]; then
		_ROOT=/
	fi
	_ROOT=$(_readlink $_ROOT)
	_info "Using root directory: $_ROOT"
	_INSTALL_BIN_PATH=$(_USE_SUDO=1 _readlink $_ROOT/$_CONF_INSTALL_BIN_PATH)
	_INSTALL_CONFIG_PATH=$(_USE_SUDO=1 _readlink $_ROOT/$_CONF_INSTALL_CONFIG_PATH)
	_INSTALL_DATA_PATH=$(_USE_SUDO=1 _readlink $_ROOT/$_CONF_INSTALL_DATA_PATH)
	_INSTALL_LIBRARY_PATH=$(_USE_SUDO=1 _readlink $_ROOT/$_CONF_INSTALL_LIBRARY_PATH)
	_APPLICATION_METADATA_PATH=$_INSTALL_LIBRARY_PATH/install/.metadata
	_include $_APPLICATION_METADATA_PATH
	if [ "$_ROOT" != "/" ]; then
		unset $(env | grep _BOOTSTRAP | cut -f1 -d=)
	fi
}
_application_settings() {
	_TARGET_APPLICATION_BUILD_DATE=$(git log --format=%cd -1)
	_TARGET_APPLICATION_INSTALL_DATE=$(date +"%a %b %d %H:%M:%S %Y %z")
	_TARGET_APPLICATION_DATA_PATH=$_INSTALL_DATA_PATH/$_TARGET_APPLICATION_NAME
	_TARGET_APPLICATION_CONFIG_PATH="$_INSTALL_CONFIG_PATH/$_TARGET_APPLICATION_NAME"
	_TARGET_APPLICATION_METADATA_PATH=$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.metadata
	_TARGET_APPLICATION_GIT_URL=$(git remote -v | awk {'print$2'} | head -1)
	mkdir -p $_INSTALL_DATA_PATH/install $_CONF_INSTALL_DATA_PATH $_TARGET_APPLICATION_DATA_PATH
	_include $_TARGET_APPLICATION_CONFIG_PATH
}
_application_defaults() {
	local default_file
	for default_file in $(find $1/defaults -type f 2>/dev/null); do
		_include $default_file
	done
}
_setup() {
	if [ ! -e $_CONF_INSTALL_DATA_REGISTRY_PATH/$_TARGET_APPLICATION_NAME/$_TARGET_PLATFORM/$1 ]; then
		return 1
	fi
	_include $_CONF_INSTALL_CONFIG_PATH/git
	_include $_CONF_INSTALL_CONFIG_PATH/install
	if [ "$_TARGET_APPLICATION_NAME" != "install" ] && [ "$_TARGET_APPLICATION_NAME" != "git" ]; then
		_include $_CONF_INSTALL_CONFIG_PATH/$_TARGET_APPLICATION_NAME
	fi
	_setup_run $1
}
_setup_run() {
	local setup_script
	for setup_script in $(find $_CONF_INSTALL_DATA_REGISTRY_PATH/$_TARGET_APPLICATION_NAME/$_TARGET_PLATFORM/$1 -type f 2>/dev/null | sort -u); do
		_setup_run_script "$setup_script"
	done
}
_setup_run_script() {
	local setup_type_name=$(basename $1)
	_variable_is_set ${setup_type_name}_disabled && return
	if [ $(printf '%s' $setup_type_name | grep -c '.') -gt 0 ]; then
		setup_type_name=$(printf '%s' $setup_type_name | sed -e "s/^.*\.//")
	fi
	if [ -z "$setup_type_name" ] || [ "$setup_type_name" = "." ]; then
		_warn "setup_type_name is corrupt: $setup_type_name ($1)"
	fi
	if [ ! -e $1 ]; then
		_warn "$1 no longer exists, ignoring"
		return 0
	fi
	_sudo mkdir -p "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type"
	_setup_run_do_bootstrap $setup_type_name
	_${setup_type_name}_is_file
	if [ $? -eq 0 ]; then
		_WARN=$_CONF_INSTALL_FEATURE_TIMEOUT_ERROR_LEVEL _${setup_type_name}_install $1 || {
			local error=$?
			_warn "Error installing: $setup_type_name: $1"
			return $error
		}
		_call _${setup_type_name}_get_data $1 | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type/.${setup_type_name}"
	else
		local packages=$($_CONF_INSTALL_GNU_GREP -Pv '(^$|^#)' $1 | tr '\n' ' ')
		_WARN=$_CONF_INSTALL_FEATURE_TIMEOUT_ERROR_LEVEL _${setup_type_name}_install $packages || {
			local error=$?
			_warn "Error installing $packages"
			return $error
		}
		printf "$packages" | tr ' ' '\n' | _write "$_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type/.${setup_type_name}"
	fi
	_call _${setup_type_name}_cleanup
	return 0
}
_setup_run_do_bootstrap() {
	_setup_type_bootstrapped $1 || {
		_call _${1}_bootstrap
		export _BOOTSTRAP_${1}=1
		printf '_BOOTSTRAP_%s=1\n' "$1" | _install_metadata_write
	}
}
_setup_type_bootstrapped() {
	_variable_is_set _BOOTSTRAP_${1}
}
_require_file() {
	if [ -z "$1" ]; then
		_error "Filename is missing ($_FILE_DETAIL_MESSAGE)"
	fi
	if [ ! -e $1 ]; then
		if [ $# -eq 2 ]; then
			_warn "File: $1 does not exist ($_FILE_DETAIL_MESSAGE)"
			return 1
		fi
		_error "File: $1 does not exist ($_FILE_DETAIL_MESSAGE)"
	fi
}
_readlink() {
	if [ $# -lt 1 ] || [ -z "$1" ]; then
		return 1
	fi
	if [ "$1" = "/" ]; then
		printf '%s\n' "$1"
		return
	fi
	if [ ! -e $1 ]; then
		if [ -z $_MKDIR ] || [ $_MKDIR -eq 1 ]; then
			local sudo
			if [ -n "$_USE_SUDO" ]; then
				sudo=$_SUDO_CMD
			fi
			$sudo mkdir -p $1 >/dev/null 2>&1
		fi
	fi
	readlink -f $1
}
_write() {
	_sudo tee -a "$1" >/dev/null
}
_online() {
	curl --connect-timeout $_CONF_INSTALL_NETWORK_TEST_TIMEOUT -s $_CONF_INSTALL_NETWORK_TEST_TARGET >/dev/null 2>&1 || return 1
}
_sed_safe() {
	printf '%s' $1 | sed -e "s/\//\\\\\//g"
}
_uninstall() {
	_require "$_TARGET_APPLICATION_NAME" "_TARGET_APPLICATION_NAME must be set"
	_require "$_INSTALL_LIBRARY_PATH" "_INSTALL_LIBRARY_PATH must be set"
	[ ! -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME ] && return 1
	[ ! -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.metadata ] && return 1
	_uninstall_script
	_uninstall_files
	_uninstall_type
	_sudo rm -Rf $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME
	_info "Uninstalled $_TARGET_APPLICATION_NAME"
}
_uninstall_script() {
	if [ -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/uninstall ]; then
		find $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/uninstall -type f -exec _sudo {} \;
	fi
}
_uninstall_files() {
	if [ -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files ]; then
		if [ "$_ROOT" = "/" ]; then
			_sudo rm -f $(cat $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files)
		else
			local sed_safe_root=$(_sed_safe $_ROOT)
			_sudo rm -f $(sed -e "s/^/$sed_safe_root/" $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files)
		fi
		_sudo rm -f $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/.files
	fi
}
_uninstall_type() {
	if [ ! -e $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type ]; then
		return 1
	fi
	for _SETUP_TYPE_FILE in $(find $_INSTALL_LIBRARY_PATH/$_TARGET_APPLICATION_NAME/type -type f -name '.*'); do
		_SETUP_TYPE_NAME=$(basename $_SETUP_TYPE_FILE | sed -e 's/^.//')
		_uninstall_type_do
	done
}
_uninstall_type_do() {
	local packages=$($_CONF_INSTALL_GNU_GREP -Pv '(^$|^#)' $_SETUP_TYPE_FILE)
	if [ -z "$packages" ]; then
		_detail "No ${_SETUP_TYPE_NAME}(s) to uninstall"
		return
	fi
	_info "Uninstalling $packages via ${_SETUP_TYPE_NAME}"
	_${_SETUP_TYPE_NAME}_uninstall $packages
}
_extract() {
	if [ $# -lt 2 ]; then
		_warn "Expecting 2 arguments, source file, and target to extract to"
		return 1
	fi
	_info "### Extracting $1"
	local _extension=$(printf '%s' "$1" | $_CONF_INSTALL_GNU_GREP -Po "\\.(tar\\.gz|tar\\.bz2|tbz2|tgz|zip|tar\\.xz)$")
	case $_extension in
	".tar.gz" | ".tgz")
		tar zxf $1 -C $2
		;;
	".zip")
		unzip -q $1 -d $2
		;;
	".tar.bz2" | ".tbz2")
		tar jxf $1 -C $2
		;;
	".tar.xz")
		xz -dc $1 | tar xf -C $2
		;;
	*)
		_warn "extension unsupported - $_extension $1"
		return 2
		;;
	esac
}
_prepare_ssh_conf() {
	_sudo mkdir -p $1/.ssh/socket
	_sudo chmod 700 $1/.ssh/socket
	printf 'StrictHostKeyChecking no\n' | _sudo tee -a $1/.ssh/config >/dev/null
	[ -n "$_HOST_IP" ] && _ssh_init_bastion_host $1
	if [ -e /tmp/HOST-SSH ]; then
		_info "Copying host ssh -> $1/.ssh"
		_sudo cp /tmp/HOST-SSH/id* $1/.ssh
	fi
	[ "$2" != "root" ] && _sudo chown -R $2:$2 $1/.ssh
}
_ssh_init_bastion_host() {
	_info "Setting up SSH Bastion host: $1"
	printf 'Host host-proxy\n' | _sudo tee -a $1/.ssh/config >/dev/null
	printf ' Hostname %s\n' "$_HOST_IP" | _sudo tee -a $1/.ssh/config >/dev/null
	printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
	printf 'Host git\n' | _sudo tee -a $1/.ssh/config >/dev/null
	printf ' ProxyJump host-proxy:%s\n' $_SSH_HOST_PORT | _sudo tee -a $1/.ssh/config >/dev/null
	printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
	printf 'Host freebsd-package-cache\n' | _sudo tee -a $1/.ssh/config >/dev/null
	printf ' ProxyJump host-proxy:%s\n' $_SSH_HOST_PORT | _sudo tee -a $1/.ssh/config >/dev/null
	printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
	printf 'Host %s\n' "$_PACKAGE_CACHE" | _sudo tee -a $1/.ssh/config >/dev/null
	printf ' ProxyJump host-proxy:%s\n' $_SSH_HOST_PORT | _sudo tee -a $1/.ssh/config >/dev/null
	printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
	if [ "$_PACKAGE_CACHE" != "$_GIT_MIRROR" ]; then
		printf 'Host %s\n' "$_GIT_MIRROR" | _sudo tee -a $1/.ssh/config >/dev/null
		printf ' ProxyJump host-proxy\n' | _sudo tee -a $1/.ssh/config >/dev/null
		printf ' User root\n' | _sudo tee -a $1/.ssh/config >/dev/null
	fi
	_sudo chmod 600 $1/.ssh/config
}
: ${_CONF_INSTALL_BEEP_TIMEOUT:=5}
: ${_CONF_INSTALL_BEEP_ERR:='L32c'}
: ${_CONF_INSTALL_BEEP_ALRT:='L32f'}
: ${_CONF_INSTALL_BEEP_SCS:='L32a'}
: ${_CONF_INSTALL_BEEP_WRN:=''}
: ${_CONF_INSTALL_BEEP_INFO:=''}
: ${_CONF_INSTALL_BEEP_DETAIL:=''}
: ${_CONF_INSTALL_BEEP_DEBUG:=''}
: ${_CONF_INSTALL_BEEP_STDIN:='L32ab'}
: ${_CONF_INSTALL_SUDO_BEEP_TONE:=L32aL8fL32c}
: ${_CONF_INSTALL_CRONTAB_ROOT_PATH:=/bin:/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/local/sbin:/opt/bin}
: ${_CONF_INSTALL_CRONTAB_USER_PATH:=/usr/local/bin:/usr/bin:/bin:/opt/bin}
_SUDO_CMD="sudo"
_ARCHITECTURE=$(uname -m)
_INSTALL_INSTALLER=pkg
_PLATFORM_PACKAGES="git gsed gnugrep gtar gawk"
_NPM_PACKAGE="npm"
_RUST_PACKAGE="rust"
_PYPI_DISABLED=1
_PYPI_PACKAGE="python39 py39-pip"
_GO_PACKAGE="go123"
GOPATH=/usr/local
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin
_CONF_INSTALL_STAT_ARGUMENTS='-f %OLp'
_PACKAGE_OPTIONS="-yq"
_PLATFORM="FreeBSD"
_TAR_ARGS=" -f - "
: ${_CONF_INSTALL_GNU_GREP:=/usr/local/bin/grep}
: ${_CONF_INSTALL_GNU_SED:=gsed}
: ${_CONF_INSTALL_CONTEXT:=$_CONSOLE_CONTEXT_ID}
: ${_CONF_INSTALL_CONTEXT:=default}
: ${_CONF_INSTALL_C_ALRT:="1;31m"}
: ${_CONF_INSTALL_C_ERR:="1;31m"}
: ${_CONF_INSTALL_C_SCS:="1;32m"}
: ${_CONF_INSTALL_C_WRN:="1;33m"}
: ${_CONF_INSTALL_C_INFO:="1;36m"}
: ${_CONF_INSTALL_C_DETAIL:="1;0;36m"}
: ${_CONF_INSTALL_C_DEBUG:="1;35m"}
: ${_CONF_INSTALL_C_STDIN:="1;34m"}
: ${_CONF_INSTALL_DATE_FORMAT:="%Y/%m/%d|%H:%M:%S"}
: ${_CONF_INSTALL_DATE_TIME_FORMAT:="%Y/%m/%d %H:%M:%S"}
: ${_CONF_INSTALL_AUDIT:=0}
: ${_CONF_INSTALL_LOG_LEVEL:=2}
: ${_CONF_INSTALL_INDENT:="  "}
: ${_CONF_INSTALL_CONF_VALIDATION_FUNCTION:=_warn}
: ${_CONF_INSTALL_WAITER_LEVEL:=_debug}
if [ -z "$_NON_INTERACTIVE" ]; then
	if [ -z "$_FORCE_INTERACTIVE" ]; then
		tty >/dev/null || _NON_INTERACTIVE=0
	fi
fi
if ! (: >&7) 2>/dev/null; then
	exec 7>&1
	exec 8>&2
fi
if [ $_NON_INTERACTIVE ]; then
	_LOG_TARGET=7
	_NLOG_TARGET=1
else
	_LOG_TARGET=8
	_NLOG_TARGET=2
fi
: ${_CONF_INSTALL_FEATURE_TIMEOUT_ERROR_LEVEL:=warn}
: ${_CONF_INSTALL_WAIT_INTERVAL:=30}
: ${_CONF_INSTALL_NO_PAGER:=0}
: ${_CONF_INSTALL_STEP_TIMEOUT:=300}
: ${_CONF_INSTALL_IOSTAT_DURATION:=5}
: ${_CONF_INSTALL_REPOSITORY_URL:=https://github.com/walterjwhite}
: ${_CONF_INSTALL_MIRROR_URLS:=https://github.com/walterjwhite}
: ${_CONF_INSTALL_SUDO_TIMEOUT:=270}
: ${_CONF_INSTALL_NETWORK_TEST_TARGET:=google.com}
: ${_CONF_INSTALL_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_INSTALL_TEAMS_MESSAGE_PARALLELIZATION:=5}
: ${_CONF_INSTALL_PARALLEL_BUILD:=8}
: ${_CONF_INSTALL_APP_REGISTRY_GIT_URL:=https://github.com/walterjwhite/app.registry.git}
: ${_CONF_INSTALL_AUTO_UPDATE_PACKAGES:=0}
: ${_CONF_INSTALL_CLEAN_APP_REGISTRY_WORKSPACE:=1}
: ${_CONF_INSTALL_RANDOM_DEFAULT_LENGTH:=8}
[ "$_CONF_INSTALL_NO_PAGER" = "1" ] && PAGER=cat
: ${_OPTN_INSTALL_BYPASS_UNINSTALL:=1}
[ "$HOME" = "/" ] && HOME=/root
: ${_CONF_INSTALL_SYSTEM_TEMPLATE_PATH:=/usr/share/git/templates}
: ${_CONF_INSTALL_LIBRARY_PATH:=/usr/local/walterjwhite}
: ${_CONF_INSTALL_BIN_PATH:=/usr/local/bin}
: ${_CONF_INSTALL_DATA_PATH:=$HOME/.data}
: ${_CONF_INSTALL_CACHE_PATH:=$_CONF_INSTALL_DATA_PATH/.cache}
: ${_CONF_INSTALL_CONFIG_PATH:=$HOME/.config/walterjwhite}
: ${_CONF_INSTALL_RUN_PATH:=/tmp/$USER/walterjwhite/app}
_CONF_INSTALL_DATA_ARTIFACTS_PATH=$_CONF_INSTALL_DATA_PATH/install/artifacts
_CONF_INSTALL_DATA_REGISTRY_PATH=$_CONF_INSTALL_DATA_PATH/install/registry
_CONF_INSTALL_APPLICATION_DATA_PATH=$_CONF_INSTALL_DATA_PATH/$_APPLICATION_NAME
_CONF_INSTALL_APPLICATION_CONFIG_PATH=$_CONF_INSTALL_CONFIG_PATH/$_APPLICATION_NAME
_CONF_INSTALL_APPLICATION_LIBRARY_PATH=$_CONF_INSTALL_LIBRARY_PATH/$_APPLICATION_NAME
: ${INSTALL_SUPPORTED_PLATFORMS:="FreeBSD Linux Windows Apple"}
: ${INSTALL_BUILD_PLATFORMS:=$INSTALL_SUPPORTED_PLATFORMS}
which pgrep >/dev/null 2>&1 && _PARENT_PROCESSES_FUNCTION=_parent_processes_pgrep
_DETECTED_PLATFORM=$(uname)
case $_DETECTED_PLATFORM in
Darwin)
	_DETECTED_PLATFORM=Apple
	;;
MINGW64_NT-*)
	_DETECTED_PLATFORM=Windows
	;;
esac
_is_backgrounded && _BACKGROUNDED=1
_init_logging
[ "$_APPLICATION_NAME" != "install" ] && _include $_CONF_INSTALL_CONFIG_PATH/install
_include $_CONF_INSTALL_APPLICATION_CONFIG_PATH
unset _DEFERS
_APPLICATION_START_TIME=$(date +%s)
_APPLICATION_CMD=$(basename $0)
[ -z "$_INSTALL_INSTALLER" ] && _PACKAGE_DISABLED=1
trap _on_exit INT 0 1 2 3 4 6 15
for _ARG in "$@"; do
	case $_ARG in
	-conf-* | -[a-z0-9][a-z0-9][a-z0-9]*)
		_configuration_name=${_ARG#*-}
		_configuration_name=${_configuration_name%%=*}
		if [ $(printf '%s' "$_configuration_name" | grep -c '_') -eq 0 ]; then
			if [ $(printf '%s' "$_configuration_name" | grep -c '^conf') -gt 0 ]; then
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/-/-$_APPLICATION_NAME-/")
			else
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/^/$_APPLICATION_NAME-/")
			fi
		fi
		_configuration_name=$(printf '%s' $_configuration_name | tr '-' '_' | tr '[:lower:]' '[:upper:]')
		if [ $(printf '%s' "$_ARG" | grep -c '=') -eq 0 ]; then
			_configuration_value=1
		else
			_configuration_value=${_ARG#*=}
		fi
		export _$_configuration_name="$_configuration_value"
		unset _configuration_name
		shift
		;;
	-h | --help)
		_print_help_and_exit
		;;
	-w=*)
		_WAITER_PID="${1#*=}"
		shift
		;;
	-w)
		_CONF_INSTALL_WAITER_LEVEL=_info
		_defer _waitee_done
		shift
		;;
	*)
		break
		;;
	esac
done
for _REQUIRED_APP_CONF_ITEM in $_REQUIRED_APP_CONF; do
	_variable_is_set $_REQUIRED_APP_CONF_ITEM || {
		_warn "$_REQUIRED_APP_CONF_ITEM is unset"
		_MISSING_REQUIRED_CONF=1
	}
done
[ -n "$_MISSING_REQUIRED_CONF" ] && _error "Required configuration is missing, please refer to above error(s)"
_ACTUAL_ARGUMENT_COUNT=$#
_DISCOVERED_ARGUMENT_COUNT=$(printf '%s' "$_REQUIRED_ARGUMENTS" | sed -e 's/$/\n/' | tr '|' '\n' | wc -l | awk {'print$1'})
_required_arguments_argument_log_level=debug
[ $_ACTUAL_ARGUMENT_COUNT -lt $_DISCOVERED_ARGUMENT_COUNT ] && _required_arguments_argument_log_level=warn
_$_required_arguments_argument_log_level "Expecting $_DISCOVERED_ARGUMENT_COUNT, received $# arguments"
_ARG_INDEX=1
_ARGUMENT_LOG_LEVEL=info
while [ $_ARG_INDEX -le $_DISCOVERED_ARGUMENT_COUNT ]; do
	_ARGUMENT_NAME=$(printf '%s' "$_REQUIRED_ARGUMENTS" | tr '|' '\n' | sed -n ${_ARG_INDEX}p | sed -e 's/:.*$//')
	_ARGUMENT_MESSAGE=$(printf '%s' "$_REQUIRED_ARGUMENTS" | tr '|' '\n' | sed -n ${_ARG_INDEX}p | sed -e 's/^.*://')
	if [ -z "$1" ]; then
		_$_required_arguments_argument_log_level "$_ARG_INDEX:$_ARGUMENT_MESSAGE was not provided"
	else
		_$_required_arguments_argument_log_level "$_ARG_INDEX:$_ARGUMENT_NAME=$1"
		export $_ARGUMENT_NAME="$1"
		shift
	fi
	_ARG_INDEX=$(($_ARG_INDEX + 1))
done
[ $_ACTUAL_ARGUMENT_COUNT -lt $_DISCOVERED_ARGUMENT_COUNT ] && _error "Missing arguments"
unset _ARG_INDEX _ARGUMENT_NAME _ARGUMENT_MESSAGE _required_arguments_argument_log_level
_DISCOVERED_REQUIRED_ARGUMENTS="$_REQUIRED_ARGUMENTS"
unset _REQUIRED_ARGUMENTS
_debug "REMAINING ARGS: $*"
if [ -z "$_CONTEXT_VALIDATED" ]; then
	_context_id_is_valid "$_CONF_INSTALL_CONTEXT"
	_CONTEXT_VALIDATED=0
fi
_APPLICATION_CONTEXT_GROUP=$_CONF_INSTALL_RUN_PATH/$_CONF_INSTALL_CONTEXT
_APPLICATION_CMD_DIR=$_APPLICATION_CONTEXT_GROUP/$_APPLICATION_NAME/$_APPLICATION_CMD
_waitee_init
_waiter
case $_DETECTED_PLATFORM in
$_PLATFORM) ;;
Apple | FreeBSD | Linux | Windows)
	_error "Please use the appropriate platform-specific installer ($_DETECTED_PLATFORM)"
	;;
*)
	_error "Unsupported platform ($_DETECTED_PLATFORM)"
	;;
esac
_APP_INSTALLATION=0
_APP_INSTALL_SELF=$(readlink -f $0)
_APPLICATION_INSTALL_DATE=$(date)
[ -z "$_INSTALL_BIN_PATH" ] && _settings_init
_online || _error "Not connected to the Internet"
if [ $# -eq 0 ]; then
	_is_app
	_TARGET_APPLICATION_NAME=$(basename $PWD)
	_info "Installing $_TARGET_APPLICATION_NAME"
	_setup_project
	exit 0
else
	if [ -z "$*" ]; then
		_error "Not an app and no apps were specified"
	fi
fi
_info "Installing $*"
for _TARGET_APPLICATION_NAME in "$@"; do
	_setup_project
done
[ $_CONF_INSTALL_AUTO_UPDATE_PACKAGES -gt 0 ] && _package_update
