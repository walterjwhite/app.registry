#!/bin/sh
set -a
_APPLICATION_NAME='gentoo-installer'
_PLATFORM="Linux"
: ${_CONF_INSTALL_GNU_GREP:=grep}
: ${_CONF_INSTALL_GNU_SED:=sed}
_ARCHITECTURE=$(uname -m)
_SUDO_CMD="sudo"
_PLATFORM_PACKAGES="git expect curl"
_NPM_PACKAGE="node"
_RUST_PACKAGE="rust"
_PYPI_PACKAGE="python"
_GO_PACKAGE="go"
: ${_CONF_INSTALL_SUDO_BEEP_TONE:=L32aL8fL32c}
_CONF_INSTALL_STAT_ARGUMENTS='-f %OLp'
: ${_CONF_INSTALL_CONTEXT:=$_CONSOLE_CONTEXT_ID}
: ${_CONF_INSTALL_CONTEXT:=default}
: ${_CONF_INSTALL_C_ALRT:="1;31m"}
: ${_CONF_INSTALL_C_ERR:="1;31m"}
: ${_CONF_INSTALL_C_SCS:="1;32m"}
: ${_CONF_INSTALL_C_WRN:="1;33m"}
: ${_CONF_INSTALL_C_INFO:="1;36m"}
: ${_CONF_INSTALL_C_DETAIL:="1;0;36m"}
: ${_CONF_INSTALL_C_DEBUG:="1;35m"}
: ${_CONF_INSTALL_C_STDIN:="1;34m"}
: ${_CONF_INSTALL_DATE_FORMAT:="%Y/%m/%d|%H:%M:%S"}
: ${_CONF_INSTALL_DATE_TIME_FORMAT:="%Y/%m/%d %H:%M:%S"}
: ${_CONF_INSTALL_BEEP_TIMEOUT:=5}
: ${_CONF_INSTALL_BEEP_ERR:='L32c'}
: ${_CONF_INSTALL_BEEP_ALRT:='L32f'}
: ${_CONF_INSTALL_BEEP_SCS:='L32a'}
: ${_CONF_INSTALL_BEEP_WRN:=''}
: ${_CONF_INSTALL_BEEP_INFO:=''}
: ${_CONF_INSTALL_BEEP_DETAIL:=''}
: ${_CONF_INSTALL_BEEP_DEBUG:=''}
: ${_CONF_INSTALL_BEEP_STDIN:='L32ab'}
: ${_CONF_INSTALL_AUDIT:=0}
: ${_CONF_INSTALL_LOG_LEVEL:=2}
: ${_CONF_INSTALL_INDENT:="  "}
: ${_CONF_INSTALL_CONF_VALIDATION_FUNCTION:=_warn}
: ${_CONF_INSTALL_WAITER_LEVEL:=_debug}
if [ -z "$_NON_INTERACTIVE" ]; then
	if [ -z "$_FORCE_INTERACTIVE" ]; then
		tty >/dev/null || _NON_INTERACTIVE=0
	fi
fi
if ! (: >&7) 2>/dev/null; then
	exec 7>&1
	exec 8>&2
fi
if [ $_NON_INTERACTIVE ]; then
	_LOG_TARGET=7
	_NLOG_TARGET=1
else
	_LOG_TARGET=8
	_NLOG_TARGET=2
fi
: ${_CONF_INSTALL_FEATURE_TIMEOUT_ERROR_LEVEL:=warn}
: ${_CONF_INSTALL_WAIT_INTERVAL:=30}
: ${_CONF_INSTALL_NO_PAGER:=0}
: ${_CONF_INSTALL_STEP_TIMEOUT:=300}
: ${_CONF_INSTALL_IOSTAT_DURATION:=5}
: ${_CONF_INSTALL_REPOSITORY_URL:=https://github.com/walterjwhite}
: ${_CONF_INSTALL_MIRROR_URLS:=https://github.com/walterjwhite}
: ${_CONF_INSTALL_SUDO_TIMEOUT:=270}
: ${_CONF_INSTALL_NETWORK_TEST_TARGET:=google.com}
: ${_CONF_INSTALL_NETWORK_TEST_TIMEOUT:=5}
: ${_CONF_INSTALL_TEAMS_MESSAGE_PARALLELIZATION:=5}
: ${_CONF_INSTALL_PARALLEL_BUILD:=8}
: ${_CONF_INSTALL_APP_REGISTRY_GIT_URL:=https://github.com/walterjwhite/app.registry.git}
: ${_CONF_INSTALL_AUTO_UPDATE_PACKAGES:=1}
: ${_CONF_INSTALL_CLEAN_APP_REGISTRY_WORKSPACE=1}
: ${_CONF_INSTALL_RANDOM_DEFAULT_LENGTH=8}
if [ "$HOME" = "/" ]; then
	HOME=/root
fi
: ${_CONF_INSTALL_SYSTEM_TEMPLATE_PATH:=/usr/share/git/templates}
: ${_CONF_INSTALL_LIBRARY_PATH:=/usr/local/walterjwhite}
: ${_CONF_INSTALL_BIN_PATH:=/usr/local/bin}
: ${_CONF_INSTALL_DATA_PATH:=$HOME/.data}
: ${_CONF_INSTALL_CACHE_PATH:=$_CONF_INSTALL_DATA_PATH/.cache}
: ${_CONF_INSTALL_CONFIG_PATH:=$HOME/.config/walterjwhite}
: ${_CONF_INSTALL_RUN_PATH:=/tmp/$USER/walterjwhite/app}
_CONF_INSTALL_DATA_ARTIFACTS_PATH=$_CONF_INSTALL_DATA_PATH/install/artifacts
_CONF_INSTALL_DATA_REGISTRY_PATH=$_CONF_INSTALL_DATA_PATH/install/registry
_CONF_INSTALL_APPLICATION_DATA_PATH=$_CONF_INSTALL_DATA_PATH/$_APPLICATION_NAME
_CONF_INSTALL_APPLICATION_CONFIG_PATH=$_CONF_INSTALL_CONFIG_PATH/$_APPLICATION_NAME
_CONF_INSTALL_APPLICATION_LIBRARY_PATH=$_CONF_INSTALL_LIBRARY_PATH/$_APPLICATION_NAME
which pgrep >/dev/null 2>&1 && _PARENT_PROCESSES_FUNCTION=_parent_processes_pgrep
_DETECTED_PLATFORM=$(uname)
case $_DETECTED_PLATFORM in
Darwin)
	_DETECTED_PLATFORM=Apple
	;;
MINGW64_NT-*)
	_DETECTED_PLATFORM=Windows
	;;
esac
: ${_CONF_GENTOO_INSTALLER_VERSION:=20250105T170325Z}
: ${_CONF_GENTOO_VERBOSE_TAR:=}
: ${GENTOO_STAGE3_TYPE:="hardened-openrc"}
: ${GENTOO_KERNEL:=gentoo-kernel}
: ${GENTOO_INIT:=dracut}
: ${GENTOO_BOOT_LOADER:=efibootmgr}
: ${GENTOO_CRON:=cronie}
: ${GENTOO_SYSLOG:=sysklogd}
: ${GENTOO_SYSLOG_USE:=logrotate}
: ${GENTOO_INDEXING:=plocate}
: ${GENTOO_L10N:="en en-US"}
: ${GENTOO_LUKS_CIPHER:=aes-xts-plain}
: ${GENTOO_LUKS_KEY_SIZE:=512}
: ${GENTOO_LUKS_HASH:=sha512}
: ${GENTOO_SOFTWARE_LICENSE:="@FREE @BINARY-REDISTRIBUTABLE"}
: ${GENTOO_TIME_SYNCHRONIZATION:=chrony}
: ${GENTOO_KERNEL:=gentoo-kernel}
: ${GENTOO_KERNEL_CMDLINE_ARGS:="consoleblank=300 quiet"}
: ${_CONF_GENTOO_INSTALLER_SYSTEM_IDENTIFICATION:="/usr/local/etc/walterjwhite/system"}
_beep() {
	if [ -n "$_BEEPING" ]; then
		_debug "Another 'beep' is in progress"
		return
	fi
	_BEEPING=1
	_do_beep "$@" &
}
_do_beep() {
	if [ -e /dev/speaker ]; then
		printf '%s' "$1" >/dev/speaker
	fi
	_beep_done
}
_beep_done() {
	unset _BEEPING
}
_sudo_precmd() {
	_beep $_CONF_INSTALL_SUDO_BEEP_TONE
}
_interactive_alert() {
	which notify-send >/dev/null 2>&1 || return 1
	[ $XAUTHORITY ] && notify-send -e "$*"
}
_mktemp() {
	mktemp -t ${_APPLICATION_NAME}.${_APPLICATION_CMD}.$1.XXXXXXXX
}
_notify() {
	local title=$1
	local message=$2
	zenity --info --text="$_APPLICATION_NAME - $_APPLICATION_CMD - $title\n$message"
}
_open() {
	xdg-open $1
}
_is_backgrounded() {
	case $(ps -o stat= -p $$) in
	*+*)
		return 1
		;;
	esac
	return 0
}
_list_pid_info() {
	_TARGET_PID=$(basename $_EXISTING_APPLICATION_PIPE)
	_TARGET_PS_DTL=$(ps -o command -p $_TARGET_PID | sed 1d | sed -e "s/^.*$_EXECUTABLE_NAME_SED_SAFE/$_EXECUTABLE_NAME_SED_SAFE/")
	_info " $_TARGET_PID - $_TARGET_PS_DTL"
}
_sudo() {
	[ $# -eq 0 ] && _error 'No arguments were provided to _sudo'
	[ $(whoami) == 'root' ] && [ -z $_SUDO_REQUIRED ] && {
		$@
		return
	}
	_require "$_SUDO_CMD" _SUDO_CMD
	if [ -z "$_NON_INTERACTIVE" ]; then
		$_SUDO_CMD -n ls >/dev/null 2>&1 || _sudo_precmd "$@"
	fi
	$_SUDO_CMD $_SUDO_OPTIONS "$@"
}
_syslog() {
	logger -i -t "$_APPLICATION_NAME.$_APPLICATION_CMD" "$1"
}
_variable_is_set() {
	[ $(env | grep "^$1=.*$" | wc -l) -gt 0 ] && return 0
	return 1
}
_has_required_conf() {
	if [ -n "$_REQUIRED_APP_CONF" ]; then
		for _REQUIRED_APP_CONF_ITEM in $(printf '%s' "$_REQUIRED_APP_CONF" | sed -e 's/$/\n/' | tr '|' '\n'); do
			_variable_is_set $_REQUIRED_APP_CONF_ITEM || {
				_warn "$_REQUIRED_APP_CONF_ITEM is unset"
				_MISSING_REQUIRED_CONF=1
			}
		done
		if [ -n "$_MISSING_REQUIRED_CONF" ]; then
			_error "Required configuration is missing, please refer to above error(s)"
		fi
	fi
}
_environment_filter() {
	grep '^_CONF_'
}
_environment_dump() {
	if [ -z "$_APPLICATION_PIPE_DIR" ]; then
		return
	fi
	if [ -z "$_ENVIRONMENT_FILE" ]; then
		_ENVIRONMENT_FILE=$_APPLICATION_PIPE_DIR/environment
	fi
	mkdir -p $(dirname $_ENVIRONMENT_FILE)
	env | _environment_filter | sort -u | grep -v '^$' | sed -e 's/=/="/' -e 's/$/"/' >>$_ENVIRONMENT_FILE
}
_environment_load() {
	if [ -n "$_ENVIRONMENT_FILE" ]; then
		if [ -e "$_ENVIRONMENT_FILE" ]; then
			. $_ENVIRONMENT_FILE 2>/dev/null
		else
			_warn "$_ENVIRONMENT_FILE does not exist!"
		fi
	fi
}
_is_feature() {
	printf '%s' $_SETUP | grep -c /feature/
}
_disable_feature() {
	if [ -z "$_FEATURE_DISABLED" ]; then
		_warn "Error installing feature: $_FEATURE ($1)"
	fi
	printf '%s\n' $(_feature_key $1)_DISABLED=1 | _metadata_write
}
_is_feature_enabled() {
	local _feature_key=$(_feature_key $1)
	if [ $(env | grep -c "^${_feature_key}_DISABLED=1$") -gt 0 ]; then
		_warn "$1 is disabled"
		return 1
	fi
	return 0
}
_feature_key() {
	printf '%s\n' "_FEATURE_${1}" | tr '[:lower:]' '[:upper:]' | tr '-' '_'
}
_call() {
	local _function_name=$1
	shift
	type $_function_name >/dev/null 2>&1
	local _return=$?
	if [ $_return -gt 0 ]; then
		_debug "${_function_name} does not exist"
		return $_return
	fi
	$_function_name "$@"
}
_require() {
	local level=error
	if [ -z "$1" ]; then
		[ -n "$_WARN" ] && level=warn
		_$level "$2 required $_REQUIRE_DETAILED_MESSAGE" $3
		return 1
	fi
	unset _REQUIRE_DETAILED_MESSAGE
}
_read_if() {
	if [ $(env | grep -c "^$2=.*") -eq 1 ]; then
		_debug "$2 is already set"
		return 1
	fi
	[ $_NON_INTERACTIVE ] && _error "Running in non-interactive mode and user input was requested: $@" 10
	_print_log 9 STDI "$_CONF_INSTALL_C_STDIN" "$_CONF_INSTALL_BEEP_STDIN" "$1 $3"
	_interactive_alert_if $1 $3
	read -r $2
}
_interactive_alert_if() {
	_is_interactive_alert_enabled && _interactive_alert "$@"
}
_is_interactive_alert_enabled() {
	grep -cq '^_OPTN_INSTALL_INTERACTIVE_ALERT=1$' $_CONF_INSTALL_APPLICATION_CONFIG_PATH 2>/dev/null
}
_read_ifs() {
	stty -echo
	_read_if "$@"
	stty echo
}
_continue_if() {
	_read_if "$1" _PROCEED "$2"
	local proceed="$_PROCEED"
	unset _PROCEED
	if [ -z "$proceed" ]; then
		_DEFAULT=$(printf '%s' $2 | awk -F'/' {'print$1'})
		proceed=$_DEFAULT
	fi
	local proceed=$(printf '%s' "$proceed" | tr '[:lower:]' '[:upper:]')
	if [ $proceed = "N" ]; then
		return 1
	fi
	return 0
}
_() {
	local _successfulExitStatus=0
	if [ -n "$_SUCCESSFUL_EXIT_STATUS" ]; then
		_successfulExitStatus=$_SUCCESSFUL_EXIT_STATUS
		unset _SUCCESSFUL_EXIT_STATUS
	fi
	_info "## $*"
	if [ -z "$_DRY_RUN" ]; then
		"$@"
		local _exit_status=$?
		if [ $_exit_status -ne $_successfulExitStatus ]; then
			if [ -n "$_ON_FAILURE" ]; then
				$_ON_FAILURE
				return
			fi
			if [ -z "$_WARN_ON_ERROR" ]; then
				_error "Previous cmd failed" $_exit_status
			else
				unset _WARN_ON_ERROR
				_warn "Previous cmd failed - $* - $_exit_status"
				_ENVIRONMENT_FILE=$(mktemp -t error) _environment_dump
				return $_exit_status
			fi
		fi
	fi
}
_optional_include() {
	if [ ! -e $1 ]; then
		_debug "_optional_include: $1 does NOT exist"
		return 1
	fi
	. $1
}
_configure() {
	_optional_include $1
}
_error() {
	if [ $# -ge 2 ]; then
		_EXIT_STATUS=$2
	else
		_EXIT_STATUS=1
	fi
	_EXIT_LOG_LEVEL=4
	_EXIT_STATUS_CODE="ERR"
	_EXIT_COLOR_CODE="$_CONF_INSTALL_C_ERR"
	_EXIT_BEEP="$_CONF_INSTALL_BEEP_ERR"
	_EXIT_MESSAGE="$1 ($_EXIT_STATUS)"
	_defer _environment_dump
	exit $_EXIT_STATUS
}
_success() {
	_EXIT_STATUS=0
	_EXIT_LOG_LEVEL=3
	_EXIT_STATUS_CODE="SCS"
	_EXIT_COLOR_CODE="$_CONF_INSTALL_C_SCS"
	_EXIT_BEEP="$_CONF_INSTALL_BEEP_SCS"
	_EXIT_MESSAGE="$1"
	exit 0
}
_contains_argument() {
	local _key=$1
	shift
	for _ARG in "$@"; do
		case $_ARG in
		$_key)
			return 0
			;;
		esac
	done
	return 1
}
_write() {
	_sudo tee -a "$1" >/dev/null
}
_value_in() {
	local level=error
	[ -n "$_WARN" ] && level=warn
	printf '%s\n' "$1" | $_CONF_INSTALL_GNU_GREP -Pcq "^($2)$" || _$level "$1 is not in ^($2)$"
}
_print_help() {
	if [ -e $2 ]; then
		_info "$1:"
		cat $2
		printf '\n'
	fi
}
_print_help_and_exit() {
	_print_help 'system-wide options' $_CONF_INSTALL_LIBRARY_PATH/install/help/default
	if [ "$_APPLICATION_NAME" != "install" ]; then
		_print_help $_APPLICATION_NAME $_CONF_INSTALL_LIBRARY_PATH/$_APPLICATION_NAME/help/default
		_print_help "$_APPLICATION_NAME/$_APPLICATION_CMD" $_CONF_INSTALL_LIBRARY_PATH/$_APPLICATION_NAME/help/$_APPLICATION_CMD
	fi
	exit 0
}
_init_logging() {
	unset _LOGFILE
	case $_CONF_INSTALL_LOG_LEVEL in
	0)
		local logfile=$(_mktemp debug)
		_warn "Writing debug contents to: $logfile"
		_set_logfile "$logfile"
		set -x
		;;
	esac
}
_set_logfile() {
	if [ -n "$1" ]; then
		_LOGFILE=$1
		mkdir -p $(dirname $1)
		exec >>$1
		exec 2>>$1
	fi
}
_reset_logging() {
	exec >&7
	exec 2>&8
}
_alert() {
	_print_log 5 ALRT "$_CONF_INSTALL_C_ALRT" "$_CONF_INSTALL_BEEP_ALRT" "$1"
	local recipients="$_OPTN_INSTALL_ALERT_RECIPIENTS"
	local subject="Alert: $0 - $1"
	if [ -z "$recipients" ]; then
		_warn "recipients is empty, aborting"
		return 1
	fi
	_mail "$recipients" "$subject" "$2"
}
_warn() {
	_print_log 3 WRN "$_CONF_INSTALL_C_WRN" "$_CONF_INSTALL_BEEP_WRN" "$1"
}
_info() {
	_print_log 2 INF "$_CONF_INSTALL_C_INFO" "$_CONF_INSTALL_BEEP_INFO" "$1"
}
_detail() {
	_print_log 2 DTL "$_CONF_INSTALL_C_DETAIL" "$_CONF_INSTALL_BEEP_DETAIL" "$1"
}
_debug() {
	_print_log 1 DBG "$_CONF_INSTALL_C_DEBUG" "$_CONF_INSTALL_BEEP_DEBUG" "($$) $1"
}
_do_log() {
	:
}
_colorize_text() {
	printf '\033[%s%s\033[0m' "$1" "$2"
}
_sed_remove_nonprintable_characters() {
	sed -e 's/[^[:print:]]//g'
}
_print_log() {
	if [ -z "$5" ]; then
		if test ! -t 0; then
			cat - | _sed_remove_nonprintable_characters |
				while read _line; do
					_print_log $1 $2 $3 $4 "$_line"
				done
			return
		fi
		return
	fi
	local _level=$1
	local _slevel=$2
	local _color=$3
	local _tone=$4
	local _message="$5"
	if [ $_level -lt $_CONF_INSTALL_LOG_LEVEL ]; then
		return
	fi
	[ -n "$_LOGGING_CONTEXT" ] && _message="$_LOGGING_CONTEXT - $_message"
	local _message_date_time=$(date +"$_CONF_INSTALL_DATE_FORMAT")
	if [ $_BACKGROUNDED ] && [ $_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD ]; then
		$_OPTN_INSTALL_BACKGROUND_NOTIFICATION_METHOD "$_slevel" "$_message" &
	fi
	_do_log "$_level" "$_slevel" "$_message"
	[ -n "$_tone" ] && _beep "$_tone"
	_log_to_file "$_slevel" "$_message_date_time" "${_LOG_INDENT}$_message"
	_log_to_console "$_color" "$_slevel" "$_message_date_time" "${_LOG_INDENT}$_message"
}
_add_logging_context() {
	if [ -z "$1" ]; then
		return 1
	fi
	if [ -z "$_LOGGING_CONTEXT" ]; then
		_LOGGING_CONTEXT="$1"
		return
	fi
	_LOGGING_CONTEXT="$_LOGGING_CONTEXT.$1"
}
_remove_logging_context() {
	if [ -z "$_LOGGING_CONTEXT" ]; then
		return 1
	fi
	case $_LOGGING_CONTEXT in
	*.*)
		_LOGGING_CONTEXT=$(printf '%s' "$_LOGGING_CONTEXT" | sed 's/\.[a-z0-9 _-]*$//')
		;;
	*)
		unset _LOGGING_CONTEXT
		;;
	esac
}
_increase_indent() {
	_LOG_INDENT="$_LOG_INDENT${_CONF_INSTALL_INDENT}"
}
_decrease_indent() {
	_LOG_INDENT=$(printf '%s' "$_LOG_INDENT" | sed -e "s/${_CONF_INSTALL_INDENT}$//")
	[ ${#_LOG_INDENT} -eq 0 ] && _reset_indent
}
_reset_indent() {
	unset _LOG_INDENT
}
_log_to_file() {
	if [ $_NON_INTERACTIVE ] || [ $_LOGFILE ]; then
		if [ $_CONF_INSTALL_AUDIT -gt 0 ]; then
			printf >&$_NLOG_TARGET '%s %s %s\n' "$1" "$2" "$3"
		else
			printf >&$_NLOG_TARGET '%s\n' "$3"
		fi
		_syslog "$3"
	fi
}
_log_to_console() {
	[ $_NO_WRITE_STDERR ] && return
	_is_open $_LOG_TARGET || return
	[ $_NON_INTERACTIVE ] && [ -z $_LOGFILE ] && return
	if [ $_CONF_INSTALL_AUDIT -gt 0 ]; then
		printf >&$_LOG_TARGET '\033[%s%s \033[0m%s %s\n' "$1" "$2" "$3" "$4"
	else
		printf >&$_LOG_TARGET '\033[%s%s \033[0m\n' "$1" "$4"
	fi
}
_is_open() {
	(: >&"$1") 2>/dev/null
}
_log_app() {
	_debug "$_APPLICATION_NAME:$_APPLICATION_CMD:$_APPLICATION_VERSION $_APPLICATION_BUILD_DATE / $_APPLICATION_INSTALL_DATE - $1 ($$)"
}
_mail() {
	if [ $# -lt 3 ]; then
		_warn "recipients[0], subject[1], message[2] is required - $# arguments provided"
		return 1
	fi
	local recipients=$(printf '%s' "$1" | tr '|' ' ')
	shift
	local subject="$1"
	shift
	local message="$1"
	shift
	printf "$message" | mail -s "$subject" $recipients
}
_time_seconds_to_human_readable() {
	_HUMAN_READABLE_TIME=$(printf '%02d:%02d:%02d' $(($1 / 3600)) $(($1 % 3600 / 60)) $(($1 % 60)))
}
_time_human_readable_to_seconds() {
	case $1 in
	*w)
		_TIME_IN_SECONDS=${1%%w}
		_TIME_IN_SECONDS=$(($_TIME_IN_SECONDS * 3600 * 8 * 5))
		;;
	*d)
		_TIME_IN_SECONDS=${1%%d}
		_TIME_IN_SECONDS=$(($_TIME_IN_SECONDS * 3600 * 8))
		;;
	*h)
		_TIME_IN_SECONDS=${1%%h}
		_TIME_IN_SECONDS=$(($_TIME_IN_SECONDS * 3600))
		;;
	*m)
		_TIME_IN_SECONDS=${1%%m}
		_TIME_IN_SECONDS=$(($_TIME_IN_SECONDS * 60))
		;;
	*s)
		_TIME_IN_SECONDS=${1%%s}
		;;
	*)
		_error "$1 was not understood"
		;;
	esac
}
_time_decade() {
	local year=$(date +%Y)
	local _end_year=$(printf '%s' $year | head -c 4 | tail -c 1)
	local _event_decade_prefix=$(printf '%s' "$year" | $_CONF_INSTALL_GNU_GREP -Po "[0-9]{3}")
	if [ "$_end_year" -eq "0" ]; then
		_event_decade_start=${_event_decade_prefix}
		_event_decade_start=$(printf '%s' "$_event_decade_start-1" | bc)
		_event_decade_end=${_event_decade_prefix}0
	else
		_event_decade_start=$_event_decade_prefix
		_event_decade_end=$_event_decade_prefix
		_event_decade_end=$(printf '%s' "$_event_decade_end+1" | bc)
		_event_decade_end="${_event_decade_end}0"
	fi
	_event_decade_start=${_event_decade_start}1
	printf '%s-%s' "$_event_decade_start" "$_event_decade_end"
}
_current_time() {
	date +$_CONF_INSTALL_DATE_TIME_FORMAT
}
_current_time_unix_epoch() {
	date +%s
}
_timeout() {
	local timeout=$1
	shift
	local message=$1
	shift
	local timeout_units='s'
	if [ $(printf '%s' "$timeout" | grep -c '[smhd]{1}') -gt 0 ]; then
		unset timeout_units
	fi
	local timeout_level=error
	if [ $_WARN ]; then
		timeout_level=warn
	fi
	local sudo_prefix
	if [ -n "$_USE_SUDO" ] && [ -n "$_SUDO_CMD" ]; then
		if [ -z "$_NON_INTERACTIVE" ]; then
			$_SUDO_CMD -n ls >/dev/null 2>&1 || _sudo_precmd "$@"
		fi
		[ -z "$USER" ] && USER=$(whoami)
		[ "$USER" != "root" ] && {
			sudo_prefix=$_SUDO_CMD
			[ $_PRESERVE_ENV ] && sudo_prefix="$sudo_prefix -E"
		}
	fi
	$sudo_prefix timeout $_OPTIONS $timeout "$@" || {
		local error_status=$?
		local error_message="Other error"
		if [ $error_status -eq 124 ]; then
			error_message="Timed Out"
		fi
		[ $_TIMEOUT_ERR_FUNCTION ] && $_TIMEOUT_ERR_FUNCTION
		_$timeout_level "_timeout: $error_message: ${timeout}${timeout_units} - $message ($error_status): $sudo_prefix timeout $_OPTIONS $timeout $* ($USER)"
		return $error_status
	}
}
_on_exit() {
	[ $_EXIT ] && return 1
	_EXIT=0
	if [ -n "$_DEFERS" ]; then
		for _DEFER in $_DEFERS; do
			_call $_DEFER
		done
		unset _DEFERS
	fi
	_waitee_done
	if [ $_EXIT_STATUS -gt 0 ]; then
		_log_level=warn
	else
		_log_level=debug
	fi
	[ "$_EXIT_MESSAGE" ] && _print_log $_EXIT_LOG_LEVEL "$_EXIT_STATUS_CODE" "$_EXIT_COLOR_CODE" "$_EXIT_BEEP" "$_EXIT_MESSAGE"
	_log_app exit
	_on_exit_beep
}
_defer() {
	_debug "deferring: $1"
	_DEFERS="$1 $_DEFERS"
}
_on_exit_beep() {
	local current_time=$(date +%s)
	local timeout=$(($current_time + $_CONF_INSTALL_BEEP_TIMEOUT))
	[ $current_time -le $timeout ] && return 1
	local beep_code
	if [ $_EXIT_STATUS -gt 0 ]; then
		beep_code="$_CONF_INSTALL_BEEP_ERR"
	else
		beep_code="$_CONF_INSTALL_BEEP_SCS"
	fi
	_beep "$beep_code" &
}
_context_id_is_valid() {
	printf '%s' "$1" | $_CONF_INSTALL_GNU_GREP -Pq '^[a-zA-Z0-9_+-]+$' || _error "Context ID *MUST* only contain alphanumeric characters and +-: '^[a-zA-Z0-9_+-]+$' | ($1)"
}
_init_application_context() {
	if [ -z "$_CONTEXT_VALIDATED" ]; then
		_context_id_is_valid "$_CONF_INSTALL_CONTEXT"
		_CONTEXT_VALIDATED=0
	fi
	_APPLICATION_CONTEXT_GROUP=$_CONF_INSTALL_RUN_PATH/$_CONF_INSTALL_CONTEXT
	_APPLICATION_CMD_DIR=$_APPLICATION_CONTEXT_GROUP/$_APPLICATION_NAME/$_APPLICATION_CMD
	_APPLICATION_PIPE=$_APPLICATION_CMD_DIR/$$
	_APPLICATION_PIPE_DIR=$(dirname $_APPLICATION_PIPE)
	mkdir -p $_APPLICATION_PIPE_DIR
	mkfifo $_APPLICATION_PIPE
	_init_configuration
	$_CONF_INSTALL_WAITER_LEVEL "($_APPLICATION_CMD) Please use -w=$$"
}
_init_configuration() {
	if [ -z "$_CONFIGURATIONS" ]; then
		if [ "$_APPLICATION_NAME" != "install" ]; then
			_configure $_CONF_INSTALL_CONFIG_PATH/install
		fi
		_configure $_CONF_INSTALL_APPLICATION_CONFIG_PATH
		return 1
	fi
	local configure
	for configure in $(printf '%s\n' $_CONFIGURATIONS); do
		_configure $_CONF_INSTALL_CONFIG_PATH/$configure
	done
}
_has_other_instances() {
	if [ $(find $_APPLICATION_CMD_DIR -maxdepth 1 -type p ! -name $$ | wc -l) -gt 0 ]; then
		return 0
	fi
	return 1
}
_waitee_done() {
	if [ -z "$_EXIT_STATUS" ]; then
		_EXIT_STATUS=0
	fi
	if [ -n "$_WAITEE" ] && [ -e $_APPLICATION_PIPE ]; then
		_info "$0 process completed, notifying ($_EXIT_STATUS)"
		printf '%s\n' "$_EXIT_STATUS" >$_APPLICATION_PIPE
		_info "$0 downstream process picked up"
	fi
	rm -f $_APPLICATION_PIPE
}
_waiter() {
	if [ -n "$_WAITER_PID" ]; then
		_UPSTREAM_APPLICATION_PIPE=$(find $_APPLICATION_CONTEXT_GROUP -type p -name $_WAITER_PID 2>/dev/null | head -1)
		if [ -z "$_UPSTREAM_APPLICATION_PIPE" ]; then
			_error "$_WAITER_PID not found"
		fi
		if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
			_warn "$_UPSTREAM_APPLICATION_PIPE does not exist, did upstream start?"
			return
		fi
		_info "Waiting for upstream to complete: $_WAITER_PID"
		while [ 1 ]; do
			if [ ! -e $_UPSTREAM_APPLICATION_PIPE ]; then
				_error "Upstream pipe no longer exists"
			fi
			_UPSTREAM_APPLICATION_STATUS=$(_timeout $_CONF_INSTALL_WAIT_INTERVAL "_waiter:upstream" cat $_UPSTREAM_APPLICATION_PIPE 2>/dev/null)
			local _UPSTREAM_STATUS=$?
			if [ $_UPSTREAM_STATUS -eq 0 ]; then
				if [ -z "$_UPSTREAM_APPLICATION_STATUS" ] || [ $_UPSTREAM_APPLICATION_STATUS -gt 0 ]; then
					_error "Upstream exited with error ($_UPSTREAM_APPLICATION_STATUS)"
				fi
				_warn "Upstream finished: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
				break
			fi
			_detail " Upstream is still running: $_UPSTREAM_APPLICATION_PIPE ($_UPSTREAM_STATUS)"
		done
	fi
}
_kill_all() {
	_do_kill_all $_APPLICATION_PIPE_DIR
}
_kill_all_group() {
	_do_kill_all $_APPLICATION_CONTEXT_GROUP
}
_do_kill_all() {
	for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
		_kill $(basename $_EXISTING_APPLICATION_PIPE)
	done
}
_kill() {
	_warn "Killing $1"
	kill -TERM $1
}
_list() {
	_list_pid_infos $_APPLICATION_PIPE_DIR
}
_list_group() {
	_list_pid_infos $_APPLICATION_CONTEXT_GROUP
}
_list_pid_infos() {
	_info "Running processes:"
	_EXECUTABLE_NAME_SED_SAFE=$(_sed_safe $0)
	for _EXISTING_APPLICATION_PIPE in $(find $1 -type p -not -name $$); do
		_list_pid_info
	done
}
_parent_processes() {
	[ -n "$_PARENT_PROCESSES_FUNCTION" ] && $_PARENT_PROCESSES_FUNCTION
}
_parent_processes_pgrep() {
	pgrep -P $1
}
_init_pager() {
	[ "$_CONF_INSTALL_NO_PAGER" = "1" ] && PAGER=cat
}
_random() {
	local length=$_CONF_INSTALL_RANDOM_DEFAULT_LENGTH
	[ -n "$1" ] && {
		length=$1
		shift
	}
	openssl rand -base64 $length
}
_defer_cleanup_temp() {
	[ -z "$_TMP_CLEANUP_DEFERS" ] && _defer _cleanup_temp
	_TMP_CLEANUP_DEFERS="${_TMP_CLEANUP_DEFERS:+$_TMP_CLEANUP_DEFERS }$1"
}
_cleanup_temp() {
	if [ -n "$_TMP_CLEANUP_DEFERS" ]; then
		rm -rf $_TMP_CLEANUP_DEFERS
		unset _TMP_CLEANUP_DEFERS
	fi
}
_configure $_CONF_INSTALL_LIBRARY_PATH/$_APPLICATION_NAME/.metadata
_configure_patches() {
	local configure_script configure_script_path configure_script_status
	for configure_script in $(find /tmp/gentoo/ -type f -name configure); do
		configure_script_path=$(dirname $configure_script)
		$configure_script
		configure_script_status=$?
		if [ $configure_script_status -eq 0 ]; then
			_detail "Keeping $configure_patch"
		else
			_configure_remove_patch $configure_script_status $configure_script_path
		fi
	done
}
_configure_remove_patch() {
	_warn "Configure returned $1 - disabling $2"
	rm -rf $2
}
_hostname() {
	_emerge_install sys-apps/dmidecode
	GENTOO_SYSTEM_IDENTIFIER=$(dmidecode 2>/dev/null | grep 'Base Board Information' -A10 | grep 'Serial Number' | cut -f2 -d':' | sed -e 's/^ //' -e 's/ //g' -e 's/\//./g' -e 's/\.//g')
	printf '%s\n' $GENTOO_SYSTEM_NAME-$GENTOO_SYSTEM_IDENTIFIER >/etc/hostname
}
_setup_chroot() {
	source /etc/profile
	env | $_CONF_INSTALL_GNU_GREP -P '(^_CONF_|^GENTOO_)' | sort -u | sed -e 's/=/="/' -e 's/$/"/' >/tmp/env-before
	_detail "Loading env"
	. /tmp/env
	env | $_CONF_INSTALL_GNU_GREP -P '(^_CONF_|^GENTOO_)' | sort -u | sed -e 's/=/="/' -e 's/$/"/' >/tmp/env-after
	cd /tmp/gentoo
	_import_gentoo_gpg_keys
	_emerge_bootstrap
	mirrorselect -s3 -b10 -o >>/etc/portage/make.conf
	printf 'L10N="%s"\n' "$GENTOO_L10N" >>/etc/portage/make.conf
	genfstab -U / >>/etc/fstab
}
_patches() {
	[ -z "$_INDEX" ] && _INDEX=0
	local module
	for module in $@; do
		_set_logfile "/var/log/walterjwhite/${_INDEX}.build.${module}"
		_reset_indent
		_INDEX=$((_INDEX + 1))
		[ ! -e /tmp/gentoo ] && _error "Configuration directory does not exist"
		cd /tmp/gentoo
		_module_run_build $module
	done
}
_module_log_status() {
	if [ $2 -gt 0 ]; then
		_warn "end - $1 error ($2)"
	else
		_info "end - $1 - success"
	fi
}
_module_get_patch_name() {
	_module_get_patch_path "$1" |
		sed -e "s/^\.\///" -e "s/\.patch$//" -e "s/^patches\///"
}
_module_get_patch_path() {
	printf '%s' "$1" | $_CONF_INSTALL_GNU_GREP -Po '^.*.\.patch'
}
_module_run_build() {
	cd /tmp/gentoo
	local module=$1
	local module_exec=$(env | grep ^_${module}_exec= | sed -e "s/^_${module}_exec=//")
	local module_type=$(env | grep ^_${module}_type= | sed -e "s/^_${module}_type=//")
	local module_options=$(env | grep ^_${module}_options= | sed -e "s/^_${module}_options=//")
	local module_is_file=$(env | grep ^_${module}_is_file= | sed -e "s/^_${module}_is_file=//")
	local module_path=$(env | grep ^_${module}_path= | sed -e "s/^_${module}_path=//")
	local module_supports_jails=$(env | grep ^_${module}_supports_jails= | sed -e "s/^_${module}_supports_jails=//")
	[ -z "$module_type" ] && module_type=f
	[ -z "$module_path" ] && module_path="$1/*"
	[ $module_is_file ] && module_path=$module
	if [ $(_module_find $module_type $module_path $module_options -print -quit | wc -l) -eq 0 ]; then
		_info "no patches found - $module_type $module_path $module_options"
		return 1
	fi
	_info "start - $module"
	_call _${module}_pre
	local module_status
	if [ -n "$module_is_file" ]; then
		_$module $(_module_find $module_type $module_path $module_options -exec $_CONF_INSTALL_GNU_GREP -Pvh '(^#|^$)' {} + | tr '\n' ' ' | sed -e 's/ $/\n/')
		module_status=$?
	else
		if [ -z "$module_exec" ]; then
			_$module $(_module_find $module_type $module_path $module_options | sort)
			module_status=$?
		else
			_module_find $module_type $module_path $module_options -exec $module_exec
			module_status=$?
		fi
	fi
	_call _${module}_post
	_module_log_status $module $module_status
}
_module_find() {
	local module_type=$1
	shift
	local module_path=$1
	shift
	local patch_path=physical
	find . -type $module_type \( -path '*/patches/any/*' -or -path "*/patches/$patch_path/*" \) -and \( -path "*/*.patch/$module_path" \) "$@" 2>/dev/null | sort
	return 0
}
_app_is_file=1
_app() {
	local app
	for app in $@; do
		app-install $app
	done
}
_chmod() {
	local chmod_file
	for chmod_file in $@; do
		. $chmod_file
		chmod $options $mode $path
		unset mode path options
	done
}
_chown() {
	local chown_file
	for chown_file in $@; do
		. $chown_file
		chown $options $owner:$group $path
		unset owner group path options
	done
}
_crontab_clear() {
	crontab -f -r -u $1 2>/dev/null
}
_crontab_get() {
	_require "$1" "Crontab User"
	_require "$2" "Crontab Filename to write to"
	crontab -u $1 -l >$2 2>/dev/null
}
_crontab_write() {
	_require "$1" "Crontab User"
	_require_file "$2" "Crontab File"
	local crontab_path
	if [ "$1" = "root" ]; then
		crontab_path="$_CONF_INSTALL_CRONTAB_ROOT_PATH"
	else
		crontab_path="$_CONF_INSTALL_CRONTAB_USER_PATH"
	fi
	if [ -n "$_OPTN_INSTALL_CRONTAB_HEADER" ]; then
		printf '%s\n\n' "$_OPTN_INSTALL_CRONTAB_HEADER" >>$2.new
		cat $2 >>$2.new
		mv $2.new $2
	fi
	grep -cqm1 '^PATH=' $2.new $2 2>/dev/null || printf 'PATH=%s\n\n' "$crontab_path" >>$2.new
	cat $2 >>$2.new
	mv $2.new $2
	crontab -u $1 $2 || {
		_warn "error writing crontab"
		cat $2
	}
}
_crontab_append() {
	_require "$1" "Crontab User"
	_require_file "$2" "Crontab File"
	[ $(wc -l "$2" | awk {'print$1'}) -eq 0 ] && return 1
	local current_crontab=$(mktemp)
	_crontab_get $1 $current_crontab
	case "$2" in
	/tmp/*) ;;
	*)
		printf '# %s\n\n' "$2" >>$current_crontab
		;;
	esac
	cat $2 >>$current_crontab
	_crontab_write $1 $current_crontab
	rm -f $current_crontab
}
_crontab_type=d
_crontab() {
	local crontabs_temp_path=$(mktemp -d)
	local crontab_file
	local crontab_user_file
	local crontab_user
	local crontabs_directory
	for crontabs_directory in $@; do
		crontab_user=$(basename $crontabs_directory)
		crontab_user_file=$crontabs_temp_path/$crontab_user
		local crontab_path
		for crontab_path in $(find -s $crontabs_directory -type f); do
			printf '# %s\n' "$crontab_path" >>$crontab_user_file
			cat $crontab_path >>$crontab_user_file
		done
	done
	for crontab_user_file in $(find -s $crontabs_temp_path -type f | sort -u); do
		crontab_user=$(basename $crontab_user_file)
		_info "Updating $crontab_user crontab"
		_crontab_append $crontab_user $crontab_user_file
		rm -f $crontab_user_file
	done
	unset user
}
_CUPS_PATH=/etc/cups
_cups_printer() {
	local cups_printer_conf
	for cups_printer_conf in $@; do
		_cups_printer_add $cups_printer_conf
	done
}
_cups_printer_add() {
	_cups_printer_exists $1 || {
		_info "Adding $1"
		cat $1 >>$_CUPS_PATH/printers.conf
	}
}
_cups_printer_exists() {
	[ ! -e $_CUPS_PATH/printers.conf ] && return 1
	local printer_uuid=$(grep ^UUID $1 | sed -e 's/UUID urn:uuid://')
	if [ $(grep -c $printer_uuid $_CUPS_PATH/printers.conf) -eq 0 ]; then
		return 1
	fi
	_warn "Printer ($printer_uuid) already exists"
	return 0
}
_download() {
	mkdir -p $_CONF_INSTALL_CACHE_PATH
	local _cached_filename
	if [ $# -gt 1 ]; then
		_cached_filename="$2"
	else
		_cached_filename=$(basename $1 | sed -e 's/?.*$//')
	fi
	_DOWNLOADED_FILE=$_CONF_INSTALL_CACHE_PATH/$_cached_filename
	if [ -e $_DOWNLOADED_FILE ]; then
		_detail "$1 already downloaded to: $_DOWNLOADED_FILE"
		return
	fi
	if [ -z "$_DOWNLOAD_DISABLED" ]; then
		_info "Downloading $1 -> $_DOWNLOADED_FILE"
		curl $_CURL_OPTIONS -o $_DOWNLOADED_FILE -s -L "$1"
	else
		_continue_if "Please manually download: $1 and place it in $_DOWNLOADED_FILE" "Y/n"
	fi
}
_download_install_file() {
	_require "$1" "1 (_download_install_file) target filename"
	_info "Installing $_DOWNLOADED_FILE -> $1"
	_sudo mkdir -p $(dirname $1)
	_sudo cp $_DOWNLOADED_FILE $1
	_sudo chmod 444 $1
	unset _DOWNLOADED_FILE
	[ ! -e $1 ] && return 1
	return 0
}
_verify() {
	[ -z "$_HASH_ALGORITHM" ] && _HASH_ALGORITHM=512
	shasum -a $_HASH_ALGORITHM -c $1 >/dev/null 2>&1
}
_extract() {
	if [ $# -lt 2 ]; then
		_warn "Expecting 2 arguments, source file, and target to extract to"
		return 1
	fi
	_info "### Extracting $1"
	local _extension=$(printf '%s' "$1" | $_CONF_INSTALL_GNU_GREP -Po "\\.(tar\\.gz|tar\\.bz2|tbz2|tgz|zip|tar\\.xz)$")
	case $_extension in
	".tar.gz" | ".tgz")
		tar zxf $1 -C $2
		;;
	".zip")
		unzip -q $1 -d $2
		;;
	".tar.bz2" | ".tbz2")
		tar jxf $1 -C $2
		;;
	".tar.xz")
		xz -dc $1 | tar xf -C $2
		;;
	*)
		_warn "extension unsupported - $_extension $1"
		return 2
		;;
	esac
}
_download() {
	local download_conf
	for download_conf in $@; do
		_do_download $download_conf
	done
}
_do_download() {
	mkdir -p /tmp/downloads
	. $1
	_download $uri
	_OUTPUT=/tmp/downloads/$(basename $_DOWNLOADED_FILE)
	cp $_DOWNLOADED_FILE $_OUTPUT
	if [ -n "$signature" ]; then
		sha256 -c $signature $_OUTPUT 2>/dev/null
		if [ $? -eq 0 ]; then
			printf '\tOK\n'
		else
			printf '\tFAIL\n'
		fi
	fi
	_extract $_OUTPUT
}
_file_type=d
_file_path='file'
_file_exec="rsync -lmrt {}/ / ;"
_fstab() {
	local fstab
	local patch_name
	for fstab in $@; do
		patch_name=$(_module_get_patch_name $fstab)
		printf '# %s\n' "$patch_name" >>/etc/fstab
		cat $fstab >>/etc/fstab
		printf '\n' >>/etc/fstab
	done
}
_go_bootstrap() {
	_go_bootstrap_is_go_available || {
		_go_bootstrap_platform
		_go_bootstrap_is_go_available || _GO_DISABLED=1
	}
}
_go_bootstrap_is_go_available() {
	which go >/dev/null 2>&1
}
_go_install() {
	GO111MODULE=on _sudo go install $_GO_OPTIONS "$@" || {
		_warn "go install failed: $_GO_OPTIONS $@"
		_warn "  http_proxy: $http_proxy"
		_warn "  git  proxy: $(git config --global http.proxy)"
	}
}
_go_update() {
	:
}
_go_uninstall() {
	_sudo go uninstall "$@"
}
_go_is_installed() {
	return 1
}
_go_is_file() {
	return 1
}
_go_is_file=1
_go() {
	_go_install "$@"
}
_group() {
	local group_conf
	for group_conf in $@; do
		_group_add $group_conf
	done
}
_group_add() {
	. $1
	_detail " add group: $1 $groupName $gid"
	groupadd -g $gid $groupName
	unset groupName gid
}
_link() {
	local link_conf
	for link_conf in $@; do
		_link_do $link_conf
	done
}
_link_do() {
	. $1
	for _TARGET in $targets; do
		_detail "ln -sf $path -> $_TARGET"
		local parent=$(dirname $_TARGET)
		if [ ! -e $path ]; then
			_warn "$path does NOT exist"
			continue
		elif [ ! -e $parent ]; then
			mkdir -p $parent
		fi
		ln -sf $path $_TARGET
	done
	unset _TARGET path targets
}
_lxd() {
	_warn "Not implemented - lxd"
}
_npm_bootstrap() {
	_npm_bootstrap_is_npm_available || {
		_npm_bootstrap_platform
		_npm_bootstrap_is_npm_available || _NPM_DISABLED=1
	}
	_npm_setup_proxy
}
_npm_bootstrap_is_npm_available() {
	which npm >/dev/null 2>&1
}
_npm_install() {
	local npm_package
	for npm_package in "$@"; do
		_npm_is_installed $npm_package || _sudo npm install -s -g "$npm_package"
	done
}
_npm_uninstall() {
	_sudo npm uninstall -s -g "$@"
}
_npm_is_installed() {
	npm list -g $1 >/dev/null
}
_npm_is_file() {
	return 1
}
_npm_setup_proxy() {
	if [ -n "$http_proxy" ]; then
		_warn "Configuring NPM to use an HTTP proxy: $http_proxy"
		npm config set proxy $http_proxy
		npm config set https-proxy $https_proxy
		_defer _npm_clear_proxy
	fi
}
_npm_clear_proxy() {
	_warn "Reverting NPM HTTP proxy: $http_proxy"
	npm config rm proxy
	npm config rm https-proxy
}
_npm_is_file=1
_npm() {
	_npm_install $@
}
_package_is_file=1
_package() {
	[ $# -eq 0 ] && _error 'No packages'
	_emerge_install "$@"
}
_use_is_file=1
_use() {
	printf '# portage use - patches\nUSE="$USE %s"\n' "$*" >>/etc/portage/make.conf
}
_post_run() {
	_run
}
_post_run_post() {
	_post_run_restore_ssh
}
_post_run_restore_ssh() {
	_detail "Restoring SSH configuration (if applicable)"
	[ -e /root/.ssh.restore ] && _post_run_restore_ssh_do /root
	for s in $(find /home -type d -depth 2 -name '.ssh.restore'); do
		_post_run_restore_ssh_do $(dirname $s)
	done
}
_post_run_restore_ssh_do() {
	_warn "Removing setup .ssh with .ssh.restore [$1]"
	rm -rf $1/.ssh
	mv $1/.ssh.restore $1/.ssh
}
_pypi_bootstrap() {
	_pypi_bootstrap_is_pypi_available || {
		_pypi_bootstrap_platform
		_pypi_bootstrap_is_pypi_available || _PYPI_DISABLED=1
	}
}
_pypi_bootstrap_is_pypi_available() {
	which pip >/dev/null 2>&1
}
_pypi_install() {
	_sudo pip install -U --no-input "$@" >/dev/null
}
_pypi_uninstall() {
	_sudo pip uninstall -y "$@" >/dev/null
}
_pypi_is_installed() {
	_error "PIP - is installed - NOT IMPLEMENTED"
}
_pypi_is_file() {
	return 1
}
_pypi_is_file=1
_pypi() {
	_pypi_install "$@"
}
_run() {
	local run_conf
	for run_conf in $@; do
		cd /tmp/gentoo
		. $run_conf || _warn "Error running $GENTOO_SYSTEM_NAME $run_conf"
	done
}
_rust_bootstrap() {
	_rust_bootstrap_is_rust_available || {
		_rust_bootstrap_platform
		_rust_bootstrap_is_rust_available || _RUST_DISABLED=1
	}
}
_rust_bootstrap_is_rust_available() {
	which cargo >/dev/null 2>&1
}
_rust_install() {
	_sudo cargo install "$@"
}
_rust_update() {
	_sudo cargo update "$@"
}
_rust_uninstall() {
	_sudo cargo uninstall "$@"
}
_rust_is_installed() {
	_error "RUST - is installed - NOT IMPLEMENTED"
}
_rust_is_file() {
	return 1
}
_rust_is_file=1
_rust() {
	_rust_install "$@"
}
_service() {
	local service_line
	$_CONF_INSTALL_GNU_GREP -Pv '^($|#)' "$@" | while read service_line; do
		rc-update add $service_line
	done
}
_sysctl_exec="$_CONF_INSTALL_APPLICATION_LIBRARY_PATH/bin/_key_value /etc/sysctl.conf {} sysctl ;"
_user_bootstrap() {
	:
}
_user_install() {
	:
}
_user_uninstall() {
	:
}
_user_is_installed() {
	return 1
}
_user_is_file() {
	return 0
}
_user_enabled() {
	return 1
}
_user_bootstrap() {
	_sudo mkdir -p /root/.ssh/socket
	_sudo chmod -R 700 /root/.ssh/socket
	app-install configuration
}
_user_install() {
	_users_add "$1"
}
_user_uninstall() {
	. "$1"
	_require "$username" "username"
	userdel $username
}
_user_is_installed() {
	:
}
_user_enabled() {
	return 0
}
_users_add_argument() {
	if [ -n "$2" ]; then
		user_options="$user_options $1 $2"
	fi
}
_users_add() {
	. $1
	if [ "root" != "$username" ]; then
		_sudo pw user show $username >/dev/null 2>&1 || {
			_info "### Add User: $1: $username"
			user_options="-m"
			_users_add_argument "-g" "$gid"
			_users_add_argument "-G" "$grouplist"
			_users_add_argument "-s" "$shell"
			_users_add_argument "-u" "$uid"
			_users_add_argument "-p" "$password"
			_sudo useradd $user_options $username
		}
	else
		_info "# Setting shell to $shell for root"
		_sudo chsh -s "$shell"
		if [ -n "$password" ]; then
			_info "# Setting root password"
			_sudo usermod -p "$password" $username
		fi
	fi
	_users_configure
	_users_cleanup
}
_users_get_data() {
	printf '%s\n' "$username" | tr ' ' '\n'
}
_users_cleanup() {
	unset user_options username gid grouplist shell uid password system
}
_users_configure() {
	local user_home=$(grep "^$username:" /etc/passwd | cut -f6 -d':')
	sudo=$SUDO_CMD _prepare_ssh_conf $user_home $username
	local original_pwd=$PWD
	cd /tmp
	if [ -n "$system" ]; then
		_warn "$username is a system user, bypassing configuration"
	else
		_warn "_CONF_FREEBSD_INSTALLER_HOSTNAME:$_CONF_FREEBSD_INSTALLER_HOSTNAME"
		_WARN_ON_ERROR=1 _NON_INTERACTIVE=1 _FREEBSD_INSTALLER=1 _NO_WRITE_STDERR=1 _SUDO_REQUIRED=1 _ _sudo \
			--preserve-env=_CONF_GIT_MIRROR,_WARN_ON_ERROR,_LOG_TARGET,_NON_INTERACTIVE,_CONF_FREEBSD_INSTALLER_HOSTNAME,_NO_WRITE_STDERR,http_proxy,https_proxy \
			-H -u $username conf restore || _user_configure_debug
	fi
	cd $original_pwd
}
_user_configure_debug() {
	_warn "Error restoring configuration for $username"
	cat $user_home/.ssh/id_*.pub
	cat $user_home/.ssh/authorized_keys
	cat $user_home/.ssh/config
}
_user() {
	_user_bootstrap
	local user_conf
	for user_conf in $@; do
		_users_add $user_conf
		unset _CONFIGURATION_INSTALLED
	done
}
_zfs_supports_jails=1
_zfs() {
	local zfs_volume_configuration
	for zfs_volume_configuration in $@; do
		if [ -n "$_IN_JAIL" ]; then
			mkdir -p /tmp/jail/zfs
			cp $zfs_volume_configuration /tmp/jail/zfs
			local zfs_volume_configuration_name=$(basename $zfs_volume_configuration)
			printf '_ZFS_JAILED=1\n' >>/tmp/jail/zfs/$zfs_volume_configuration_name
			printf '_ZFS_JAIL=%s\n' $_JAIL_NAME >>/tmp/jail/zfs/$zfs_volume_configuration_name
			printf '_ZFS_VOLUME_NAME=jails/%s/$_ZFS_VOLUME_NAME\n' $_JAIL_NAME >>/tmp/jail/zfs/$zfs_volume_configuration_name
		else
			_zfs_restore $zfs_volume_configuration
			unset _ZFS_DEV_NAME _ZFS_SOURCE_HOST _ZFS_VOLUME_NAME _ZFS_VOLUME_ABORT_CREATE _ZFS_ZAP_SNAP _ZFS_ZAP_TTL _ZFS_ZAP_BACKUP _ZFS_MOUNT_POINT _ZFS_VOLUME
		fi
	done
}
_zfs_jails() {
	_detail "Processing jail ZFS configurations"
	local jail_mountpoint
	for jail_mountpoint in $(_jail_mount_points); do
		local zfs_jail_conf=$jail_mountpoint/tmp/jail/zfs
		if [ -e $zfs_jail_conf ]; then
			_detail "Processing jail ZFS configuration: $zfs_jail"
			_zfs $(find $zfs_jail_conf -type f 2>/dev/null)
		fi
	done
}
_zfs_restore() {
	_info "_zfs_restore: $1"
	mkdir -p ~/.ssh/socket
	chmod 700 ~/.ssh/socket
	. $1
	[ -z "$_ZFS_DEV_NAME" ] && {
		_warn "_ZFS_DEV_NAME is empty"
		return 1
	}
	[ -z "$_ZFS_SOURCE_HOST" ] && {
		_warn "_ZFS_SOURCE_HOST is empty"
		return 1
	}
	[ -z "$_ZFS_VOLUME_NAME" ] && {
		_warn "_ZFS_VOLUME_NAME is empty"
		return 1
	}
	_ZFS_VOLUME=${_ZFS_DEV_NAME}/$_ZFS_VOLUME_NAME
	_ZFS_SOURCE_SNAPSHOT=$(ssh $_ZFS_SOURCE_HOST zfs list -H -t snapshot | grep $_ZFS_VOLUME_NAME@ | grep -v backups | tail -1 | awk {'print$1'})
	[ -z "$_ZFS_SOURCE_SNAPSHOT" ] && {
		_warn "No snapshots available, unable to setup clone: $_ZFS_VOLUME"
		return 1
	}
	_zfs_has_sufficient_space || return 1
	_info "zfs create $_ZFS_VOLUME"
	zfs create -p $_ZFS_VOLUME
	[ -n "$_ZFS_MOUNT_POINT" ] && zfs set mountpoint=$_ZFS_MOUNT_POINT $_ZFS_VOLUME
	[ -n "$_ZFS_JAILED" ] && zfs set jailed=on $_ZFS_VOLUME
	zfs set readonly=on $_ZFS_VOLUME
	ssh $_ZFS_SOURCE_HOST zfs send -v $_ZFS_SOURCE_SNAPSHOT | zfs receive -F $_ZFS_VOLUME
	zfs allow -g wheel bookmark,diff,hold,send,snapshot $_ZFS_VOLUME
	if [ -n "$_CONF_SYSTEM_MAINTENANCE_ZFS_USER" ]; then
		zfs allow -u $_CONF_SYSTEM_MAINTENANCE_ZFS_USER bookmark,diff,hold,send,snapshot $_ZFS_VOLUME
	fi
	_zfs_zap
	_zfs_rclone
	_info "zfs create $_ZFS_VOLUME - done"
}
_zfs_has_sufficient_space() {
	_ZFS_SNAPSHOT_SPACE=$(ssh $_ZFS_SOURCE_HOST zfs list -t snapshot $_ZFS_SOURCE_SNAPSHOT | awk '{print$4}' | grep "G$" | sed -e "s/G$//")
	_ZFS_SNAPSHOT_REQUIRED_SPACE=$(printf '2 * %s\n' "$_ZFS_SNAPSHOT_SPACE" | bc)
	_ZPOOL_FREE_SPACE=$(zpool list -H $_ZFS_DEV_NAME | awk '{print$4}' | grep "G$" | sed -e "s/G$//")
	if [ $(printf '%s < %s\n' "$_ZFS_SNAPSHOT_REQUIRED_SPACE" "$_ZPOOL_FREE_SPACE" | bc) -eq 0 ]; then
		_warn "Insufficient free space: $_ZFS_VOLUME_NAME - $_ZFS_SNAPSHOT_SPACE $_ZFS_SNAPSHOT_REQUIRED_SPACE $_ZPOOL_FREE_SPACE"
		return 1
	fi
	_info "Setting up $_ZFS_VOLUME_NAME - $_ZFS_SNAPSHOT_SPACE $_ZFS_SNAPSHOT_REQUIRED_SPACE $_ZPOOL_FREE_SPACE"
}
_start_ssh() {
	netstat -tlpn | grep -cq :22
	if [ $? -eq 0 ]; then
		_warn "Unable to start SSHd as it is already running"
	else
		rc-service sshd start
		GENTOO_SSHD_STARTED=1
	fi
	local ips=$(ip addr show scope global | grep inet | sed -e 's/ brd.*//' -e 's/inet //' -e 's/ //g')
	_warn "IP: $ips"
}
_stop_ssh() {
	[ -z "$GENTOO_SSHD_STARTED" ] && return 1
	rc-service sshd stop
}
_system() {
	_hostname
	_locale
	_timezone
	_time_synchronization
	_init_$GENTOO_INIT
	_kernel
	_boot_loader_$GENTOO_BOOT_LOADER
	_cron_$GENTOO_CRON
	_syslog_$GENTOO_SYSLOG
	_indexing_$GENTOO_INDEXING
}
_import_override() {
	_import_load $1 $2 && {
		IMPORT_PATH=$2
		return
	}
	[ ! -e imports ] && return 1
	local imported_system
	for imported_system in $(ls imports); do
		_import_load $1 imports/$imported_system && {
			IMPORT_PATH=imports/$imported_system
			return
		}
	done
}
_import_load() {
	[ -e $2 ] && {
		$1 $2
		return
	}
	return 1
}
_boot_loader_efibootmgr() {
	_emerge_install sys-boot/efibootmgr
	_boot_loader_efibootmgr_args
	_boot_loader_efibootmgr_install
}
_boot_loader_efibootmgr_args() {
	GENTOO_BOOT_LOADER_ARGS="$GENTOO_KERNEL_CMDLINE_ARGS"
	[ -n "$GENTOO_DISK_DEVICE_LUKS" ] && {
		GENTOO_BOOT_LOADER_LUKS_DEVICE_UUID=$(lsblk -no name,uuid $GENTOO_DISK_DEVICE_LUKS | head -1 | awk {'print$2'}) || _error "Unable to determine UUID for $GENTOO_DISK_DEVICE_LUKS"
		GENTOO_BOOT_LOADER_ARGS="$GENTOO_BOOT_LOADER_ARGS rd.luks.UUID=$GENTOO_BOOT_LOADER_LUKS_DEVICE_UUID"
	}
	[ -n "$GENTOO_ZFS_POOL_NAME" ] && {
		GENTOO_BOOT_LOADER_ARGS="$GENTOO_BOOT_LOADER_ARGS root=zfs:$GENTOO_ZFS_POOL_NAME/gentoo"
	}
}
_boot_loader_efibootmgr_install() {
	local kernel kernel_version
	for kernel in $(find /boot -maxdepth 1 -name 'vmlinuz*' ! -name '*.old'); do
		kernel_version=$(printf '%s' $kernel | sed -e 's/vmlinuz-//' -e 's/^\/boot\///')
		[ ! -e /efi/EFI/gentoo/$kernel_version ] && {
			mkdir -p /efi/EFI/gentoo/$kernel_version
			cp /boot/vmlinuz-$kernel_version /efi/EFI/gentoo/$kernel_version/kernel
			cp /boot/initramfs-$kernel_version.img /efi/EFI/gentoo/$kernel_version/initramfs
			cp /boot/System.map-$kernel_version /efi/EFI/gentoo/$kernel_version/System.map
			cp /boot/config-$kernel_version /efi/EFI/gentoo/$kernel_version/config
			_boot_loader_efibootmgr_create "$kernel_version"
		}
	done
}
_boot_loader_efibootmgr_create() {
	efibootmgr --create --disk $GENTOO_DISK_DEVICE --part $GENTOO_DISK_DEVICE_BOOT_PARTITION_ID --label "Gentoo $GENTOO_SYSTEM_NAME - $1" --loader \
		"\\EFI\\gentoo\\$1\\kernel" --unicode "$GENTOO_BOOT_LOADER_ARGS initrd=\\EFI\\gentoo\\$1\\initramfs"
}
_boot_loader_efibootmgr_delete() {
	local efi_boot_line efi_boot_id local gentoo_kernel_version
	efibootmgr -u | $_CONF_INSTALL_GNU_GREP -P '^Boot[\d]{4}' | while read efi_boot_line; do
		efi_boot_id=$(printf '%s' "$efi_boot_line" | sed -e 's/^Boot//' -e 's/ .*$//' -e 's/\*//')
		gentoo_kernel_version=$(printf '%s' "$efi_boot_line" | sed -e 's/.*\\EFI\\gentoo\\//' -e 's/\\.*$//' | $_CONF_INSTALL_GNU_GREP -P '[\d]{1,}\..*' | head -1)
		[ ! -e /boot/vmlinuz-$gentoo_kernel_version ] && {
			_warn "Deleting boot entry: $efi_boot_id - $gentoo_kernel_version no longer exists"
			rm -rf /efi/EFI/gentoo/$gentoo_kernel_version
			efibootmgr -B -b $efi_boot_id
		}
	done
}
_boot_loader_grub() {
	printf 'GRUB_PLATFORMS="efi-64"\n' >>/etc/portage/make.conf
	[ -n "$GENTOO_ZFS_POOL_NAME" ] && {
		printf "sys-boot/grub libzfs\n" >>/etc/portage/package.use/grub
	}
	_emerge_install sys-boot/grub sys-boot/shim sys-boot/mokutil sys-boot/efibootmgr
	grub-probe /boot
	grub-probe /boot/efi
	cp /usr/share/shim/BOOTX64.EFI /efi/EFI/Gentoo/shimx64.efi
	cp /usr/share/shim/mmx64.efi /efi/EFI/Gentoo/mmx64.efi
	cp /usr/lib/grub/grub-x86_64.efi.signed /efi/EFI/Gentoo/grubx64.efi
	grub-install --efi-directory=/efi
	mkdir -p /etc/env.d
	printf 'GRUB_CFG=/efi/EFI/Gentoo/grub.cfg\n' >>/etc/env.d/99grub
}
_boot_loader_secure_boot() {
	[ -z "$GENTOO_KERNEL_KEY_PEM" ] && return 1
	[ -z "$GENTOO_KERNEL_KEY_DER" ] && return 2
	_package app-crypt/sbsigntools
	openssl x509 -in "$GENTOO_KERNEL_KEY_PEM" -inform PEM -out "$GENTOO_KERNEL_KEY_DER" -outform DER
	mokutil --import "$GENTOO_KERNEL_KEY_DER"
	efibootmgr --create --disk /dev/boot-disk --part boot-partition-id --loader '\EFI\Gentoo\shimx64.efi' --label 'GRUB via Shim' --unicode
}
_cron_cronie() {
	_emerge_install sys-process/cronie
	_service cronie boot
}
_firmware() {
	mkdir -p /etc/portage/package.license
	printf 'sys-kernel/linux-firmware linux-fw-redistributable\n' >>/etc/portage/package.license/firmware
	_emerge_install sys-kernel/linux-firmware
	case $GENTOO_CPU_VENDOR in
	Intel)
		printf 'sys-firmware/intel-microcode intel-ucode\n' >>/etc/portage/package.license/firmware
		_emerge_install sys-firmware/intel-microcode
		;;
	*)
		_warn "Unknown CPU: $GENTOO_CPU_VENDOR"
		;;
	esac
}
_indexing_plocate() {
	_emerge_install sys-apps/plocate
}
_init_bliss() {
	_emerge_install bliss-initramfs
}
_init_dracut() {
	mkdir -p /etc/dracut.conf.d
	printf 'sys-kernel/installkernel dracut\n' >>/etc/portage/package.use/installkernel
	local dracut_modules="rootfs-block"
	[ -n "$GENTOO_DISK_DEVICE_LUKS" ] && dracut_modules="$dracut_modules crypt dm "
	[ -n "$GENTOO_ZFS_POOL_NAME" ] && dracut_modules="$dracut_modules zfs"
	[ -z "$GENTOO_FSCK" ] && printf 'nofsck="yes"\n' >>/etc/dracut.conf.d/no-fsck
	printf 'add_dracutmodules+=" %s"\n' "$dracut_modules" >>/etc/dracut.conf.d/modules
}
_init_ugrd() {
	:
}
_kernel() {
	printf 'USE="$USE %s"\n' "$GENTOO_INIT" >>/etc/portage/make.conf
	case $GENTOO_KERNEL in
	*-kernel | *-kernel-bin)
		GENTOO_DIST_KERNEL=1
		;;
	*)
		printf 'USE="$USE symlink"\n' >>/etc/portage/make.conf
		;;
	esac
	_emerge_install sys-kernel/$GENTOO_KERNEL
	case $GENTOO_KERNEL in
	*-kernel | *-kernel-bin) ;;
	*)
		_detail "Building kernel $GENTOO_KERNEL"
		local opwd=$PWD
		cd /usr/src/linux
		make && make modules_install && make install
		cd $opwd
		;;
	esac
	_firmware
	[ -n "$GENTOO_ZFS_POOL_NAME" ] && {
		[ -n "$GENTOO_DIST_KERNEL" ] && {
			printf 'USE="$USE dist-kernel"\n' >>/etc/portage/make.conf
			printf 'sys-fs/zfs dist-kernel-cap\n' >>/etc/portage/package.use/zfs
		}
		_emerge_install sys-fs/zfs sys-fs/zfs-kmod
		_service zfs-import boot
		_service zfs-mount boot
		_service zfs-zed boot
		emerge --config sys-kernel/$GENTOO_KERNEL >>/var/log/gentoo-kernel.dracut 2>&1
	}
}
_locale() {
	_import_override _locale_install .
	locale-gen
	local import_path=$IMPORT_PATH
	_detail "Import Path: $import_path"
	unset IMPORT_PATH
	local system_locale=$($_CONF_INSTALL_GNU_GREP -Pvh '(^$|^#)' $import_path/system/locale/locale.eselect | head -1)
	eselect locale set $system_locale
	. /etc/profile
}
_locale_install() {
	cp $1/system/locale/locale.gen /etc/locale.gen 2>/dev/null
}
_syslog_sysklogd() {
	[ -n "$GENTOO_SYSLOG_USE" ] && printf 'app-admin/sysklogd %s\n' "$GENTOO_SYSLOG_USE" >>/etc/portage/package.use/sysklogd
	_emerge_install app-admin/sysklogd
	_service sysklogd boot
}
_time_synchronization() {
	_time_synchronization_$GENTOO_TIME_SYNCHRONIZATION
}
_time_synchronization_chrony() {
	_emerge_install net-misc/chrony
	rc-update add chronyd
}
_timezone() {
	ln -sf /usr/share/zoneinfo/$GENTOO_SYSTEM_TIMEZONE /etc/localtime
}
_file() {
	[ ! -e $1/file ] && return 1
	tar cp -C $1/file | tar xp -C /
}
_import_gentoo_gpg_keys() {
	gpg --import /usr/share/openpgp-keys/gentoo-release.asc
	_defer _gpg_kill
}
_gpg_verify() {
	_require "$1" "File to verify with GPG"
	local gpg_output=$(gpg -q --verify "$1" 2>&1)
	local gpg_status=$?
	[ $gpg_status -gt 0 ] && _error "$gpg_output" $gpg_status
}
_gpg_kill() {
	killall gpg-agent
	killall keyboxd
}
_service() {
	[ ! -e $1/service ] && return 1
	local service_line
	$_CONF_INSTALL_GNU_GREP -Pvh '(^$|^#)' $1/service |
		while read service_line; do
			rc-update add $service_line
		done
}
_ZFS_RCLONE_PACKAGE=rclone
_zfs_rclone() {
	local rclone_patch_path=patches/zfs-rclone.patch/rclone.post-run
	mkdir -p $(dirname $rclone_patch_path)
	if [ -n "$_ZFS_RCLONE_TARGET" ]; then
		_info "Configuring ZFS rclone target: $_ZFS_RCLONE_TARGET on $_ZFS_VOLUME"
		[ ! -e $rclone_patch_path ] && printf 'pkg install -yq %s\n' $_ZFS_RCLONE_PACKAGE >>$rclone_patch_path
		zfs set rclone:target=$_ZFS_RCLONE_TARGET $_ZFS_VOLUME
	fi
	[ -n "$_ZFS_RCLONE_PATH" ] && zfs set rclone:path=$_ZFS_RCLONE_PATH $_ZFS_VOLUME
	unset _ZFS_RCLONE_PATH _ZFS_RCLONE_TARGET
}
_ZFS_ZAP_PACKAGE=zap
_zfs_zap() {
	local zap_patch_path=patches/zfs-zap.patch/zap.post-run
	mkdir -p $(dirname $zap_patch_path)
	if [ -n "$_ZFS_ZAP_SNAP" ]; then
		_warn "Detected ZFS ZAP, setting up zap"
		[ ! -e $zap_patch_path ] && printf 'pkg install -yq %s\n' $_ZFS_ZAP_PACKAGE >>$zap_patch_path
		printf 'zfs allow -u zap bookmark,diff,hold,send,snapshot %s\n' $_ZFS_VOLUME >>$zap_patch_path
		zfs set zap:snap=on $_ZFS_VOLUME
	fi
	[ -n "$_ZFS_ZAP_TTL" ] && zfs set zap:ttl=$_ZFS_ZAP_TTL $_ZFS_VOLUME
	[ -n "$_ZFS_ZAP_BACKUP" ] && zfs set zap:backup=$_ZFS_ZAP_BACKUP $_ZFS_VOLUME
	unset _ZFS_ZAP_TTL _ZFS_ZAP_BACKUP _ZFS_ZAP_SNAP
}
_time_seconds_to_human_readable() {
	_HUMAN_READABLE_TIME=$(printf '%02d:%02d:%02d' $(($1 / 3600)) $(($1 % 3600 / 60)) $(($1 % 60)))
}
_time_human_readable_to_seconds() {
	case $1 in
	*w)
		_TIME_IN_SECONDS=${1%%w}
		_TIME_IN_SECONDS=$(($_TIME_IN_SECONDS * 3600 * 8 * 5))
		;;
	*d)
		_TIME_IN_SECONDS=${1%%d}
		_TIME_IN_SECONDS=$(($_TIME_IN_SECONDS * 3600 * 8))
		;;
	*h)
		_TIME_IN_SECONDS=${1%%h}
		_TIME_IN_SECONDS=$(($_TIME_IN_SECONDS * 3600))
		;;
	*m)
		_TIME_IN_SECONDS=${1%%m}
		_TIME_IN_SECONDS=$(($_TIME_IN_SECONDS * 60))
		;;
	*s)
		_TIME_IN_SECONDS=${1%%s}
		;;
	*)
		_error "$1 was not understood"
		;;
	esac
}
_time_decade() {
	local year=$(date +%Y)
	local _end_year=$(printf '%s' $year | head -c 4 | tail -c 1)
	local _event_decade_prefix=$(printf '%s' "$year" | $_CONF_INSTALL_GNU_GREP -Po "[0-9]{3}")
	if [ "$_end_year" -eq "0" ]; then
		_event_decade_start=${_event_decade_prefix}
		_event_decade_start=$(printf '%s' "$_event_decade_start-1" | bc)
		_event_decade_end=${_event_decade_prefix}0
	else
		_event_decade_start=$_event_decade_prefix
		_event_decade_end=$_event_decade_prefix
		_event_decade_end=$(printf '%s' "$_event_decade_end+1" | bc)
		_event_decade_end="${_event_decade_end}0"
	fi
	_event_decade_start=${_event_decade_start}1
	printf '%s-%s' "$_event_decade_start" "$_event_decade_end"
}
_current_time() {
	date +$_CONF_INSTALL_DATE_TIME_FORMAT
}
_current_time_unix_epoch() {
	date +%s
}
_timeout() {
	local timeout=$1
	shift
	local message=$1
	shift
	local timeout_units='s'
	if [ $(printf '%s' "$timeout" | grep -c '[smhd]{1}') -gt 0 ]; then
		unset timeout_units
	fi
	local timeout_level=error
	if [ $_WARN ]; then
		timeout_level=warn
	fi
	local sudo_prefix
	if [ -n "$_USE_SUDO" ] && [ -n "$_SUDO_CMD" ]; then
		if [ -z "$_NON_INTERACTIVE" ]; then
			$_SUDO_CMD -n ls >/dev/null 2>&1 || _sudo_precmd "$@"
		fi
		[ -z "$USER" ] && USER=$(whoami)
		[ "$USER" != "root" ] && {
			sudo_prefix=$_SUDO_CMD
			[ $_PRESERVE_ENV ] && sudo_prefix="$sudo_prefix -E"
		}
	fi
	$sudo_prefix timeout $_OPTIONS $timeout "$@" || {
		local error_status=$?
		local error_message="Other error"
		if [ $error_status -eq 124 ]; then
			error_message="Timed Out"
		fi
		[ $_TIMEOUT_ERR_FUNCTION ] && $_TIMEOUT_ERR_FUNCTION
		_$timeout_level "_timeout: $error_message: ${timeout}${timeout_units} - $message ($error_status): $sudo_prefix timeout $_OPTIONS $timeout $* ($USER)"
		return $error_status
	}
}
_emerge_update() {
	_emerge_bootstrap
	_sudo emerge $_EMERGE_OPTIONS --newuse -uD world -q $@
	_sudo emerge $_EMERGE_OPTIONS --depclean -q $@
}
_emerge_install() {
	_emerge_bootstrap
	_sudo emerge $_EMERGE_OPTIONS -q $@
}
_emerge_uninstall() {
	_emerge_bootstrap
	_sudo emerge $_EMERGE_OPTIONS --depclean -q $@
}
_emerge_is_installed() {
	$_CONF_INSTALL_GNU_GREP -Pcq "^${1}$" /var/lib/portage/world
}
_emerge_bootstrap() {
	[ -n "$_EMERGE_BOOTSTRAPPED" ] && return
	cp /usr/share/portage/config/repos.conf /etc/portage/repos.conf
	ASSUME_ALWAYS_YES=yes
	_EMERGE_BOOTSTRAPPED=1
	if [ -n "$_ROOT" ] && [ "$_ROOT" != "/" ]; then
		_EMERGE_OPTIONS="--root=$_ROOT"
	fi
	_sudo emerge $_EMERGE_OPTIONS --sync -q
	_sudo emerge $_EMERGE_OPTIONS --oneshot -q \
		app-eselect/eselect-repository \
		app-portage/mirrorselect \
		app-portage/cpuid2cpuflags \
		sys-apps/pciutils \
		sys-fs/dosfstools \
		sys-fs/genfstab
}
_emerge_bootstrap_platform() {
	_emerge_bootstrap
}
_emerge_bootstrap_is_emerge_available() {
	return 0
}
_SUB_PLATFORM=$(grep '^NAME=.*' /etc/os-release | sed -e 's/^NAME=//' | tr -d '"')
case $_SUB_PLATFORM in
Gentoo)
	_INSTALL_INSTALLER=emerge
	;;
Ubuntu | Debian)
	_INSTALL_INSTALLER=apt
	;;
CentOS | RedHat)
	_INSTALL_INSTALLER=yum
	;;
*)
	_error "Unsupported Linux Distribution: $_SUB_PLATFORM"
	;;
esac
case $_DETECTED_PLATFORM in
$_PLATFORM) ;;
Apple | FreeBSD | Linux | Windows)
	_error "Please use the appropriate platform-specific installer ($_DETECTED_PLATFORM)"
	;;
*)
	_error "Unsupported platform ($_DETECTED_PLATFORM)"
	;;
esac
_APPLICATION_START_TIME=$(date +%s)
_APPLICATION_CMD=$(basename $0)
unset _DEFERS
_is_backgrounded && _BACKGROUNDED=1
[ -z "$_INSTALL_INSTALLER" ] && _PACKAGE_DISABLED=1
for _ARG in "$@"; do
	case $_ARG in
	-h | --help)
		_print_help_and_exit
		;;
	-kill-all)
		_kill_all
		_success "Killed all"
		;;
	-kill-all-group)
		_kill_all_group
		_success "Killed all group"
		;;
	-kill=*)
		_kill ${_ARG#*=}
		_success "Killed ${_ARG#*=}"
		;;
	-lr)
		_list
		_success "listed running processes"
		shift
		;;
	-lg)
		_list_group
		_success "listed running processes"
		;;
	-w=*)
		_WAITER_PID="${1#*=}"
		shift
		;;
	-w)
		_CONF_INSTALL_WAITER_LEVEL=_info
		_WAITEE=1
		shift
		;;
	-conf-* | -[a-z0-9][a-z0-9][a-z0-9]*)
		_configuration_name=${_ARG#*-}
		_configuration_name=${_configuration_name%%=*}
		if [ $(printf '%s' "$_configuration_name" | grep -c '_') -eq 0 ]; then
			if [ $(printf '%s' "$_configuration_name" | grep -c '^conf') -gt 0 ]; then
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/-/-$_APPLICATION_NAME-/")
			else
				_configuration_name=$(printf '%s' "$_configuration_name" | sed -e "s/^/$_APPLICATION_NAME-/")
			fi
		fi
		_configuration_name=$(printf '%s' $_configuration_name | tr '-' '_' | tr '[:lower:]' '[:upper:]')
		if [ $(printf '%s' "$_ARG" | grep -c '=') -eq 0 ]; then
			_configuration_value=1
		else
			_configuration_value=${_ARG#*=}
		fi
		export _$_configuration_name="$_configuration_value"
		unset _configuration_name
		shift
		;;
	*)
		break
		;;
	esac
done
trap _on_exit INT 0 1 2 3 4 6 15
_init_logging
_init_application_context
_debug "REMAINING ARGS: $*"
_log_app init
_init_pager
_waiter
_has_required_conf
if [ -n "$_REQUIRED_ARGUMENTS" ]; then
	_DISCOVERED_ARGUMENT_COUNT=$(printf '%s' "$_REQUIRED_ARGUMENTS" | sed -e 's/$/\n/' | tr '|' '\n' | wc -l | awk {'print$1'})
	_required_arguments_argument_log_level=debug
	_ACTUAL_ARGUMENT_COUNT=$#
	[ $_ACTUAL_ARGUMENT_COUNT -lt $_DISCOVERED_ARGUMENT_COUNT ] && _required_arguments_argument_log_level=warn
	_$_required_arguments_argument_log_level "Expecting $_DISCOVERED_ARGUMENT_COUNT, received $# arguments"
	_INDEX=1
	_ARGUMENT_LOG_LEVEL=info
	while [ $_INDEX -le $_DISCOVERED_ARGUMENT_COUNT ]; do
		_ARGUMENT_NAME=$(printf '%s' "$_REQUIRED_ARGUMENTS" | tr '|' '\n' | sed -n ${_INDEX}p | sed -e 's/:.*$//')
		_ARGUMENT_MESSAGE=$(printf '%s' "$_REQUIRED_ARGUMENTS" | tr '|' '\n' | sed -n ${_INDEX}p | sed -e 's/^.*://')
		if [ -z "$1" ]; then
			_$_required_arguments_argument_log_level "$_INDEX:$_ARGUMENT_MESSAGE was not provided"
		else
			_$_required_arguments_argument_log_level "$_INDEX:$_ARGUMENT_NAME=$1"
			export $_ARGUMENT_NAME="$1"
			shift
		fi
		_INDEX=$(($_INDEX + 1))
	done
	[ $_ACTUAL_ARGUMENT_COUNT -lt $_DISCOVERED_ARGUMENT_COUNT ] && _error "Missing arguments"
	unset _INDEX _ARGUMENT_NAME _ARGUMENT_MESSAGE _required_arguments_argument_log_level
	_DISCOVERED_REQUIRED_ARGUMENTS="$_REQUIRED_ARGUMENTS"
	unset _REQUIRED_ARGUMENTS
else
	_debug "NO _REQUIRED_ARGUMENTS args"
	unset _DISCOVERED_REQUIRED_ARGUMENTS _DISCOVERED_ARGUMENT_COUNT
fi
if [ "$(whoami)" = "root" ]; then
	if [ -n "$_SUDO_CMD" ]; then
		_SUDO_NORMAL_USER_CMD="$_SUDO_CMD -u $USER"
	fi
fi
_set_logfile /var/log/gentoo-install.log
_setup_chroot
_start_ssh
_system
_configure_patches
_patches lxd zfs sysctl download use
_patches file link fstab cups_printer package service
_patches group user app go npm rust pypi
_patches chown chmod run crontab post_run
_stop_ssh
